<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Creating Multivariate Rings · Oscar.jl</title><meta name="title" content="Creating Multivariate Rings · Oscar.jl"/><meta property="og:title" content="Creating Multivariate Rings · Oscar.jl"/><meta property="twitter:title" content="Creating Multivariate Rings · Oscar.jl"/><meta name="description" content="Documentation for Oscar.jl."/><meta property="og:description" content="Documentation for Oscar.jl."/><meta property="twitter:description" content="Documentation for Oscar.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Oscar.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../Nemo/finitefield/">Finite fields</a></li><li><a class="tocitem" href="../../Fields/algebraic_closure_fp/">Algebraic closure of finite prime fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../NumberTheory/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Creating Multivariate Rings</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Coefficient-Rings"><span>Coefficient Rings</span></a></li><li><a class="tocitem" href="#Gradings"><span>Gradings</span></a></li><li><a class="tocitem" href="#Tests-on-Graded-Rings"><span>Tests on Graded Rings</span></a></li><li><a class="tocitem" href="#Data-Associated-to-Multivariate-Rings"><span>Data Associated to Multivariate Rings</span></a></li><li><a class="tocitem" href="#Elements-of-Multivariate-Rings"><span>Elements of Multivariate Rings</span></a></li><li><a class="tocitem" href="#Homomorphisms-From-Multivariate-Rings"><span>Homomorphisms From Multivariate Rings</span></a></li></ul></li><li><a class="tocitem" href="../ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li></ul></li><li><a class="tocitem" href="../homological_algebra/">Homological Algebra</a></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Gröbner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../GroebnerBases/groebner_bases/">Gröbner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../GroebnerBases/groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-10" type="checkbox"/><label class="tocitem" for="menuitem-9-10"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/">Morphisms of covered schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/ProjectiveSchemes/">Projective schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/">Morphisms of projective schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Algebraic Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/">Affine Algebraic Sets</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/">Projective Algebraic Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Algebraic Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicVarieties/AffineVariety/">Affine Varieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/">Projective Varieties</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Rational Points</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/RationalPoints/Affine/">Affine</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/RationalPoints/Projective/">Projective</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricSchemes/">Toric Schemes</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/">Toric Ideal Sheaves (Experimental)</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/ToricVarieties/BlowdownMorphisms/">Toric Blowdown Morphisms (Experimental)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/AffinePlaneCurves/">Affine plane curves</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/ProjectiveCurves/">Projective Curves</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Curves/ProjectivePlaneCurves/">Projective Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-9" type="checkbox"/><label class="tocitem" for="menuitem-11-9"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../../Combinatorics/partitions/">Partitions</a></li><li><a class="tocitem" href="../../Combinatorics/tableaux/">Tableaux</a></li><li><a class="tocitem" href="../../Combinatorics/schur_polynomials/">Schur polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../TropicalGeometry/semiring/">Tropical semirings, matrices, and polynomials</a></li><li><a class="tocitem" href="../../TropicalGeometry/semiring_map/">Tropical semiring maps</a></li><li><a class="tocitem" href="../../TropicalGeometry/variety/">Tropical varieties</a></li><li><a class="tocitem" href="../../TropicalGeometry/hypersurface/">Tropical hypersurfaces</a></li><li><a class="tocitem" href="../../TropicalGeometry/curve/">Tropical curves</a></li><li><a class="tocitem" href="../../TropicalGeometry/linear_space/">Tropical linear spaces</a></li><li><a class="tocitem" href="../../TropicalGeometry/groebner_theory/">Groebner theory</a></li><li><a class="tocitem" href="../../TropicalGeometry/tropicalization/">Tropicalization of polynomial ideals</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/printing_details/">Details on printing in Oscar</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/serialization/">Serialization</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../DeveloperDocumentation/gap_integration/">GAP Integration</a></li><li><input class="collapse-toggle" id="menuitem-18-9" type="checkbox"/><label class="tocitem" for="menuitem-18-9"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-19" type="checkbox"/><label class="tocitem" for="menuitem-19"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-19-2" type="checkbox"/><label class="tocitem" for="menuitem-19-2"><span class="docs-label">Bases for highest weight modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/BasisLieHighestWeight/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/BasisLieHighestWeight/user_functions/">User-facing functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-3" type="checkbox"/><label class="tocitem" for="menuitem-19-3"><span class="docs-label">Double complexes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/DoubleAndHyperComplexes/user_interface/">Double complexes – the user&#39;s interface</a></li><li><a class="tocitem" href="../../Experimental/DoubleAndHyperComplexes/advice_for_the_programmer/">Advice for the programmer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-4" type="checkbox"/><label class="tocitem" for="menuitem-19-4"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/weierstrass/">Weierstrass models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/tate/">Global Tate models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/hypersurface/">Hypersurface models</a></li><li><a class="tocitem" href="../../Experimental/FTheoryTools/literature/">Literature constructions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-5" type="checkbox"/><label class="tocitem" for="menuitem-19-5"><span class="docs-label">Lie Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/LieAlgebras/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/lie_algebras/">Lie algebras</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/ideals_and_subalgebras/">Ideals and Lie subalgebras</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/lie_algebra_homs/">Lie algebra homomorphisms</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/modules/">Lie algebra modules</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/module_homs/">Lie algebra module homomorphisms</a></li><li><a class="tocitem" href="../../Experimental/LieAlgebras/cartan_matrix/">Cartan Matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-6" type="checkbox"/><label class="tocitem" for="menuitem-19-6"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../Experimental/LinearQuotients/cox_rings/">Cox rings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-7" type="checkbox"/><label class="tocitem" for="menuitem-19-7"><span class="docs-label">Matroid Realization Spaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/MatroidRealizationSpaces/introduction/">Matroid Realization Spaces</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-8" type="checkbox"/><label class="tocitem" for="menuitem-19-8"><span class="docs-label">Quadratic forms and isometries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/introduction/">Quadratic forms and isometries</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/spacewithisom/">Quadratic spaces with isometry</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/latwithisom/">Lattices with isometry</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/enumeration/">Enumeration of isometries</a></li><li><a class="tocitem" href="../../Experimental/QuadFormAndIsom/primembed/">Nikulin&#39;s theory on primitive embeddings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-9" type="checkbox"/><label class="tocitem" for="menuitem-19-9"><span class="docs-label">Standard Finite Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/StandardFiniteFields/introduction/">-</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-10" type="checkbox"/><label class="tocitem" for="menuitem-19-10"><span class="docs-label">Orthogonal discriminants</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/introduction/">Introduction</a></li><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/access/">Access to precomputed OD data</a></li><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/compute/">Criteria for computing orthogonal discriminants</a></li><li><a class="tocitem" href="../../Experimental/OrthogonalDiscriminants/misc/">Miscellaneous functions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Commutative Algebra</a></li><li class="is-active"><a href>Creating Multivariate Rings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Creating Multivariate Rings</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Creating-Multivariate-Rings"><a class="docs-heading-anchor" href="#Creating-Multivariate-Rings">Creating Multivariate Rings</a><a id="Creating-Multivariate-Rings-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Multivariate-Rings" title="Permalink"></a></h1><p>In this section, for the convenience of the reader, we recall from the chapters on rings and fields how to create multivariate polynomial rings and their elements, adding illustrating examples. At the same time, we introduce and illustrate a ring type for modelling multivariate polynomial rings with gradings.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>OSCAR provides types for dense univariate and sparse multivariate polynomials. The univariate ring types belong to the abstract type <code>PolyRing{T}</code>, their elements have abstract type <code>PolyRingElem{T}</code>. The multivariate ring types belong to the abstract type <code>MPolyRing{T}</code>, their elements have abstract type <code>MPolyRingElem{T}</code>. Here, <code>T</code> is the element type of the coefficient ring of the polynomial ring.</p><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><p>The basic constructor below allows one to build multivariate polynomial rings:</p><pre><code class="language- hljs">polynomial_ring(C::Ring, V::Vector{String}; ordering=:lex, cached::Bool = true)</code></pre><p>Its return value is a tuple, say <code>R, vars</code>, consisting of a polynomial ring <code>R</code> with coefficient ring <code>C</code> and a vector <code>vars</code> of generators (variables) which print according to the strings in the vector <code>V</code> . The input <code>ordering=:lex</code> refers to the lexicograpical monomial ordering which specifies the default way of storing and displaying polynomials in OSCAR  (terms are sorted in descending order). The other possible choices are <code>:deglex</code> and <code>:degrevlex</code>. Gröbner bases, however, can be computed with respect to any monomial ordering. See the section on Gröbner bases.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Caching is used to ensure that a given ring constructed from given parameters is unique in the system. For example, there is only one ring of multivariate polynomials over  <span>$\mathbb{Z}$</span> with variables printing as x, y, z, and  with <code>ordering=:lex</code>.</p></div></div><h6 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(ZZ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over ZZ, ZZMPolyRingElem[x, y, z])

julia&gt; typeof(R)
ZZMPolyRing

julia&gt; typeof(x)
ZZMPolyRingElem

julia&gt; S, (a, b, c) = polynomial_ring(ZZ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over ZZ, ZZMPolyRingElem[x, y, z])

julia&gt; T, _ = polynomial_ring(ZZ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over ZZ, ZZMPolyRingElem[x, y, z])

julia&gt; R === S === T
true</code></pre><pre><code class="language-julia-repl hljs">julia&gt; R1, x = polynomial_ring(QQ, [&quot;x&quot;])
(Multivariate polynomial ring in 1 variable over QQ, QQMPolyRingElem[x])

julia&gt; typeof(x)
Vector{QQMPolyRingElem} (alias for Array{QQMPolyRingElem, 1})

julia&gt; R2, (x,) = polynomial_ring(QQ, [&quot;x&quot;])
(Multivariate polynomial ring in 1 variable over QQ, QQMPolyRingElem[x])

julia&gt; typeof(x)
QQMPolyRingElem

julia&gt; R3, x = polynomial_ring(QQ, &quot;x&quot;)
(Univariate polynomial ring in x over QQ, x)

julia&gt; typeof(x)
QQPolyRingElem
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; T, x = polynomial_ring(GF(3), [&quot;x[1]&quot;, &quot;x[2]&quot;]);

julia&gt; x
2-element Vector{fpMPolyRingElem}:
 x[1]
 x[2]
</code></pre><p>The constructor illustrated below allows for the convenient handling of variables with multi-indices:</p><pre><code class="language-julia-repl hljs">julia&gt; R, x, y, z = polynomial_ring(QQ, &quot;x&quot; =&gt; (1:3, 1:4), &quot;y&quot; =&gt; 1:2, &quot;z&quot; =&gt; (1:1, 1:1, 1:1));

julia&gt; x
3×4 Matrix{QQMPolyRingElem}:
 x[1, 1]  x[1, 2]  x[1, 3]  x[1, 4]
 x[2, 1]  x[2, 2]  x[2, 3]  x[2, 4]
 x[3, 1]  x[3, 2]  x[3, 3]  x[3, 4]

julia&gt; y
2-element Vector{QQMPolyRingElem}:
 y[1]
 y[2]

julia&gt; z
1×1×1 Array{QQMPolyRingElem, 3}:
[:, :, 1] =
 z[1, 1, 1]
</code></pre><h2 id="Coefficient-Rings"><a class="docs-heading-anchor" href="#Coefficient-Rings">Coefficient Rings</a><a id="Coefficient-Rings-1"></a><a class="docs-heading-anchor-permalink" href="#Coefficient-Rings" title="Permalink"></a></h2><p>Gröbner and standard bases are implemented for multivariate polynomial rings over the fields and rings below:</p><h3 id="The-field-of-rational-numbers-\\mathbb{Q}"><a class="docs-heading-anchor" href="#The-field-of-rational-numbers-\\mathbb{Q}">The field of rational numbers <span>$\mathbb{Q}$</span></a><a id="The-field-of-rational-numbers-\\mathbb{Q}-1"></a><a class="docs-heading-anchor-permalink" href="#The-field-of-rational-numbers-\\mathbb{Q}" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; QQ
Rational field
</code></pre><h3 id="Finite-fields-\\mathbb{F_p},-p-a-prime"><a class="docs-heading-anchor" href="#Finite-fields-\\mathbb{F_p},-p-a-prime">Finite fields <span>$\mathbb{F_p}$</span>, <span>$p$</span> a prime</a><a id="Finite-fields-\\mathbb{F_p},-p-a-prime-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-fields-\\mathbb{F_p},-p-a-prime" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; GF(3)
Finite field of characteristic 3

julia&gt; GF(ZZ(2)^127 - 1)
Finite field of characteristic 170141183460469231731687303715884105727
</code></pre><h3 id="Finite-fields-\\mathbb{F}_{pn}-with-pn-elements,-p-a-prime"><a class="docs-heading-anchor" href="#Finite-fields-\\mathbb{F}_{pn}-with-pn-elements,-p-a-prime">Finite fields <span>$\mathbb{F}_{p^n}$</span> with <span>$p^n$</span> elements, <span>$p$</span> a prime</a><a id="Finite-fields-\\mathbb{F}_{pn}-with-pn-elements,-p-a-prime-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-fields-\\mathbb{F}_{pn}-with-pn-elements,-p-a-prime" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; finite_field(2, 70, &quot;a&quot;)
(Finite field of degree 70 over GF(2), a)
</code></pre><h3 id="Simple-algebraic-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p"><a class="docs-heading-anchor" href="#Simple-algebraic-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p">Simple algebraic extensions of <span>$\mathbb{Q}$</span> or <span>$\mathbb{F}_p$</span></a><a id="Simple-algebraic-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-algebraic-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; T, t = polynomial_ring(QQ, &quot;t&quot;)
(Univariate polynomial ring in t over QQ, t)

julia&gt; K, a = number_field(t^2 + 1, &quot;a&quot;)
(Number field of degree 2 over QQ, a)

julia&gt; F = GF(3)
Finite field of characteristic 3

julia&gt; T, t = polynomial_ring(F, &quot;t&quot;)
(Univariate polynomial ring in t over GF(3), t)

julia&gt; K, a = finite_field(t^2 + 1, &quot;a&quot;)
(Finite field of degree 2 over GF(3), a)
</code></pre><h3 id="Purely-transcendental-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p"><a class="docs-heading-anchor" href="#Purely-transcendental-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p">Purely transcendental extensions of <span>$\mathbb{Q}$</span> or <span>$\mathbb{F}_p$</span></a><a id="Purely-transcendental-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p-1"></a><a class="docs-heading-anchor-permalink" href="#Purely-transcendental-extensions-of-\\mathbb{Q}-or-\\mathbb{F}_p" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; T, t = polynomial_ring(QQ, &quot;t&quot;)
(Univariate polynomial ring in t over QQ, t)

julia&gt; QT = fraction_field(T)
Fraction field
  of univariate polynomial ring in t over QQ

julia&gt; parent(t)
Univariate polynomial ring in t over QQ

julia&gt; parent(1//t)
Fraction field
  of univariate polynomial ring in t over QQ

julia&gt; T, (s, t) = polynomial_ring(GF(3), [&quot;s&quot;, &quot;t&quot;]);

julia&gt; QT = fraction_field(T)
Fraction field
  of multivariate polynomial ring in 2 variables over GF(3)
</code></pre><h3 id="The-ring-of-integers-\\mathbb{Z}"><a class="docs-heading-anchor" href="#The-ring-of-integers-\\mathbb{Z}">The ring of integers <span>$\mathbb{Z}$</span></a><a id="The-ring-of-integers-\\mathbb{Z}-1"></a><a class="docs-heading-anchor-permalink" href="#The-ring-of-integers-\\mathbb{Z}" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; ZZ
Integer ring
</code></pre><h2 id="Gradings"><a class="docs-heading-anchor" href="#Gradings">Gradings</a><a id="Gradings-1"></a><a class="docs-heading-anchor-permalink" href="#Gradings" title="Permalink"></a></h2><p>Given a polynomial ring <span>$R = C[x_1, \dots, x_n]$</span>, we may endow <span>$R$</span> with various gradings. The <em>standard <span>$\mathbb Z$</span>-grading</em>  on <span>$R$</span> is the decomposition <span>$R=\bigoplus_{d\in \mathbb Z} R_d=\bigoplus_{d\geq 0} R_d$</span> by the usual degree of polynomials. More general <span>$\mathbb Z$</span>-gradings are obtained by assigning integer weights to the variables and considering the corresponding weighted degrees. Even more generally, we may consider multigradings: Given a finitely generated abelian group <span>$G$</span>, a <em>multigrading</em> on <span>$R$</span> by <span>$G$</span>, or a <em><span>$G$</span>-grading</em>, or simply a <em>grading</em>, corresponds to a semigroup homomorphism <span>$\phi: \mathbb N^n \to G$</span>: Given <span>$\phi$</span>, the <em>degree</em> of a monomial <span>$x^\alpha$</span> is the image <span>$\deg(x^\alpha):=\phi(\alpha)\in G$</span>; the induced <span>$G$</span>-grading on <span>$R$</span> is the decomposition <span>$R = \bigoplus_{g\in G} R_g$</span> satisfying <span>$R_g\cdot R_h\subset R_{g+h}$</span>, where <span>$R_g$</span> is the free <span>$C$</span>-module generated by the monomials of degree <span>$g$</span>. This grading is determined by assigning the <em>weights</em> <span>$\deg(x_i)$</span> to the <span>$x_i$</span>. In other words, it is determined by  the <em>weight vector</em> <span>$W = (\deg(x_1), \dots, \deg(x_n))\in G^n.$</span></p><p>We refer to the textbooks [<a href="../../references/#MS05">MS05</a>] and [<a href="../../references/#KR05">KR05</a>] for details on multigradings. With respect to notation, we follow the former book.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Given a <span>$G$</span>-grading on <span>$R$</span>, we refer to <span>$G$</span> as the <em>grading group</em> of <span>$R$</span>. Moreover, we then say that <span>$R$</span> is <em><span>$G$</span>-graded</em>, or simply that <span>$R$</span> is <em>graded</em>. If <span>$R$</span> is a polynomial ring over a field, we say that a <span>$G$</span>-grading on <span>$R$</span> is <em>positive</em> if <span>$G$</span> is free and each graded part <span>$R_g$</span>, <span>$g\in G$</span>, has finite dimension. We then also say that <span>$R$</span> is <em>positively graded (by <span>$G$</span>)</em>. Note that the positivity condition can be equivalently expressed by asking that <span>$G$</span> is free and that the degree zero part consists of the constants only (see Theorem 8.6 in [<a href="../../references/#MS05">MS05</a>]).</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Given a  <code>G</code>-grading on <code>R</code> in OSCAR, we say that <code>R</code> is <em><span>$\mathbb Z^m$</span>-graded</em> if <code>is_free(G) &amp;&amp; ngens(G) == rank(G) == m</code> evaluates to <code>true</code>. In this case, conversion routines allow one to switch back and forth between elements of <code>G</code> and integer vectors of length <code>m</code>. Specifically, if <code>R</code> is <em><span>$\mathbb Z$</span>-graded</em>, that is, <code>is_free(G) &amp;&amp; ngens(G) == rank(G) == 1</code> evaluates to <code>true</code>,  elements of <code>G</code> may be converted to integers and vice versa.</p></div></div><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><p>Multivariate rings with gradings are modelled by objects of type <code>MPolyDecRing{T, S}  :&lt; MPolyRing{T}</code>, with elements of type <code>MPolyRingElem_dec{T, S}  :&lt; MPolyRingElem{T}</code>. Here, <code>S</code> is the element type of the multivariate ring, and  <code>T</code> is the element type of its coefficient ring as above.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The types <code>MPolyDecRing{T, S}</code> and <code>MPolyRingElem_dec{T, S}</code> are also meant to eventually model multivariate rings with filtrations and their elements.</p></div></div><p>The following function allows one, in particular, to distinguish between graded and filtered rings.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_graded-Tuple{MPolyRing}" href="#is_graded-Tuple{MPolyRing}"><code>is_graded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_graded(R::MPolyRing)</code></pre><p>Return <code>true</code> if <code>R</code> is graded, <code>false</code> otherwise.</p></div></section></article><h3 id="Constructors-for-Graded-Rings"><a class="docs-heading-anchor" href="#Constructors-for-Graded-Rings">Constructors for Graded Rings</a><a id="Constructors-for-Graded-Rings-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-for-Graded-Rings" title="Permalink"></a></h3><p>There are two basic ways of creating multivariate rings with gradings: While the <code>grade</code> function allows one to create a graded ring by assigning a grading to a polynomial ring already constructed, the <code>graded_polynomial_ring</code> function is meant to create a graded polynomial ring all at once.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="grade-Tuple{MPolyRing, Vector{GrpAbFinGenElem}}" href="#grade-Tuple{MPolyRing, Vector{GrpAbFinGenElem}}"><code>grade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grade(R::MPolyRing, W::Vector{GrpAbFinGenElem})</code></pre><p>Given a vector <code>W</code> of <code>ngens(R)</code> elements of a finitely presented group <code>G</code>, say, create a  <code>G</code>-graded ring by assigning the entries of <code>W</code> as weights to the variables of <code>R</code>. Return the new ring as an object of type <code>MPolyDecRing</code>, together with the vector of variables.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (t, x, y) = polynomial_ring(QQ, [&quot;t&quot;, &quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[t, x, y])

julia&gt; typeof(R)
QQMPolyRing

julia&gt;  typeof(x)
QQMPolyRingElem

julia&gt; G = abelian_group([0])
GrpAb: Z

julia&gt; g = gen(G, 1)
Element of G with components [1]

julia&gt; S, (t, x, y) = grade(R, [-g, g, g])
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[t, x, y])

julia&gt; typeof(S)
MPolyDecRing{QQFieldElem, QQMPolyRing}

julia&gt; S isa MPolyRing
true

julia&gt; typeof(x)
MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}

julia&gt; R, x, y = polynomial_ring(QQ, &quot;x&quot; =&gt; 1:2, &quot;y&quot; =&gt; 1:3)
(Multivariate polynomial ring in 5 variables over QQ, QQMPolyRingElem[x[1], x[2]], QQMPolyRingElem[y[1], y[2], y[3]])

julia&gt; G = abelian_group([0, 0])
GrpAb: Z^2

julia&gt; g = gens(G)
2-element Vector{GrpAbFinGenElem}:
 Element of G with components [1 0]
 Element of G with components [0 1]

julia&gt; W = [g[1], g[1], g[2], g[2], g[2]];

julia&gt; S, _ = grade(R, W)
(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], y[1], y[2], y[3]])

julia&gt; typeof(x[1])
QQMPolyRingElem

julia&gt; x = map(S, x)
2-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 x[1]
 x[2]

julia&gt; y = map(S, y)
3-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 y[1]
 y[2]
 y[3]

julia&gt; typeof(x[1])
MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}

julia&gt; R, x = polynomial_ring(QQ, &quot;x&quot; =&gt; 1:5)
(Multivariate polynomial ring in 5 variables over QQ, QQMPolyRingElem[x[1], x[2], x[3], x[4], x[5]])

julia&gt; G = abelian_group([0, 0, 2, 2])
(General) abelian group with relation matrix
[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]

julia&gt; g = gens(G);

julia&gt; W = [g[1]+g[3]+g[4], g[2]+g[4], g[1]+g[3], g[2], g[1]+g[2]]
5-element Vector{GrpAbFinGenElem}:
 Element of G with components [1 0 1 1]
 Element of G with components [0 1 0 1]
 Element of G with components [1 0 1 0]
 Element of G with components [0 1 0 0]
 Element of G with components [1 1 0 0]

julia&gt; S, x = grade(R, W)
(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4], x[5]])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="grade-Tuple{MPolyRing, Vector{&lt;:Vector{&lt;:Union{Integer, ZZRingElem}}}}" href="#grade-Tuple{MPolyRing, Vector{&lt;:Vector{&lt;:Union{Integer, ZZRingElem}}}}"><code>grade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grade(R::MPolyRing, W::AbstractVector{&lt;:AbstractVector{&lt;:IntegerUnion}})</code></pre><p>Given a vector <code>W</code> of <code>ngens(R)</code> integer vectors of the same size <code>m</code>, say, create a free  abelian group of type <code>GrpAbFinGen</code> given by <code>m</code> free generators, and convert the vectors in <code>W</code> to elements of that group. Then create a <span>$\mathbb Z^m$</span>-graded ring by assigning the group  elements as weights to the variables of <code>R</code>, and return the new ring, together with the vector of variables.</p><pre><code class="nohighlight hljs">grade(R::MPolyRing, W::Union{ZZMatrix, AbstractMatrix{&lt;:IntegerUnion}})</code></pre><p>As above, converting the columns of <code>W</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, x, y = polynomial_ring(QQ, &quot;x&quot; =&gt; 1:2, &quot;y&quot; =&gt; 1:3)
(Multivariate polynomial ring in 5 variables over QQ, QQMPolyRingElem[x[1], x[2]], QQMPolyRingElem[y[1], y[2], y[3]])

julia&gt; W = [1 1 0 0 0; 0 0 1 1 1]
2×5 Matrix{Int64}:
 1  1  0  0  0
 0  0  1  1  1

julia&gt; grade(R, W)
(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], y[1], y[2], y[3]])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="grade-Tuple{MPolyRing, Vector{&lt;:Union{Integer, ZZRingElem}}}" href="#grade-Tuple{MPolyRing, Vector{&lt;:Union{Integer, ZZRingElem}}}"><code>grade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grade(R::MPolyRing, W::AbstractVector{&lt;:IntegerUnion})</code></pre><p>Given a vector <code>W</code> of <code>ngens(R)</code> integers, create a free abelian group of type <code>GrpAbFinGen</code>  given by one free generator, and convert the entries of <code>W</code> to elements of that group. Then  create a <span>$\mathbb Z$</span>-graded ring by assigning the group elements as weights to the variables  of <code>R</code>, and return the new ring, together with the vector of variables.</p><pre><code class="nohighlight hljs">grade(R::MPolyRing)</code></pre><p>As above, where the grading is the standard <span>$\mathbb Z$</span>-grading on <code>R</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; W = [1, 2, 3];

julia&gt; S, (x, y, z) = grade(R, W)
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])

julia&gt; T, (x, y, z) = grade(R)
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="graded_polynomial_ring-Tuple{Ring, Vector{String}, Any}" href="#graded_polynomial_ring-Tuple{Ring, Vector{String}, Any}"><code>graded_polynomial_ring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">graded_polynomial_ring(C::Ring, args...; weights, kwargs...)</code></pre><p>Create a multivariate <a href="../../AbstractAlgebra/mpolynomial/#polynomial_ring-Tuple{Ring, Vector{Union{Char, AbstractString, Symbol}}}"><code>polynomial_ring</code></a> with coefficient ring <code>C</code> and variables as described by <code>args...</code> (using the exact same syntax as <code>polynomial_ring</code>), and <a href="../ModulesOverMultivariateRings/free_modules/#grade-Tuple{FreeMod, Vector{GrpAbFinGenElem}}"><code>grade</code></a> this ring according to the data provided by the keyword argument <code>weights</code>. Return the graded ring as an object of type <code>MPolyDecRing</code>, together with the variables.</p><p>If <code>weights</code> is omitted the grading is the standard <span>$\mathbb Z$</span>-grading, i.e. all variables are graded with weight <code>1</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W = [[1, 0], [0, 1], [1, 0], [4, 1]]
4-element Vector{Vector{Int64}}:
 [1, 0]
 [0, 1]
 [1, 0]
 [4, 1]

julia&gt; R, x = graded_polynomial_ring(QQ, 4, :x; weights = W)
(Graded multivariate polynomial ring in 4 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x1, x2, x3, x4])

julia&gt; S, (x, y, z) = graded_polynomial_ring(QQ, [:x, :y, :z]; weights = [1, 2, 3])
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])

julia&gt; T, x = graded_polynomial_ring(QQ, :x =&gt; 1:3)
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]])

julia&gt; T, x, y = graded_polynomial_ring(QQ, :x =&gt; 1:3, :y =&gt; (1:2, 1:2); weights=1:7)
(Graded multivariate polynomial ring in 7 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3]], MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[y[1, 1] y[1, 2]; y[2, 1] y[2, 2]])</code></pre></div></section></article><h2 id="Tests-on-Graded-Rings"><a class="docs-heading-anchor" href="#Tests-on-Graded-Rings">Tests on Graded Rings</a><a id="Tests-on-Graded-Rings-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-on-Graded-Rings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_standard_graded-Tuple{MPolyDecRing}" href="#is_standard_graded-Tuple{MPolyDecRing}"><code>is_standard_graded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_standard_graded(R::MPolyDecRing)</code></pre><p>Return <code>true</code> if <code>R</code> is standard <span>$\mathbb Z$</span>-graded, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]; weights = [1, 2, 3])
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])

julia&gt; is_standard_graded(S)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_z_graded-Tuple{MPolyDecRing}" href="#is_z_graded-Tuple{MPolyDecRing}"><code>is_z_graded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_z_graded(R::MPolyDecRing)</code></pre><p>Return <code>true</code> if <code>R</code> is <span>$\mathbb Z$</span>-graded, <code>false</code> otherwise.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Writing <code>G = grading_group(R)</code>, we say that <code>R</code> is <span>$\mathbb Z$</span>-graded if <code>is_free(G) &amp;&amp; ngens(G) == rank(G) == 1</code> evaluates to <code>true</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]; weights = [1, 2, 3])
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])

julia&gt; is_z_graded(S)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_zm_graded-Tuple{MPolyDecRing}" href="#is_zm_graded-Tuple{MPolyDecRing}"><code>is_zm_graded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_zm_graded(R::MPolyDecRing)</code></pre><p>Return <code>true</code> if <code>R</code> is <span>$\mathbb Z^m$</span>-graded for some <span>$m$</span>, <code>false</code> otherwise.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Writing <code>G = grading_group(R)</code>, we say that <code>R</code> is <span>$\mathbb Z^m$</span>-graded if <code>is_free(G) &amp;&amp; ngens(G) == rank(G) == m</code> evaluates to <code>true</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = abelian_group([0, 0, 2, 2])
(General) abelian group with relation matrix
[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]

julia&gt; W = [G[1]+G[3]+G[4], G[2]+G[4], G[1]+G[3], G[2], G[1]+G[2]];

julia&gt; S, x = graded_polynomial_ring(QQ, &quot;x&quot; =&gt; 1:5; weights=W)
(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4], x[5]])

julia&gt; is_zm_graded(S)
false

julia&gt; G = abelian_group(ZZMatrix([1 -1]));

julia&gt; g = gen(G, 1)
Element of G with components [0 1]

julia&gt; W = [g, g, g, g];

julia&gt; R, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], W);

julia&gt; is_free(G)
true

julia&gt; is_zm_graded(R)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_positively_graded-Tuple{MPolyDecRing}" href="#is_positively_graded-Tuple{MPolyDecRing}"><code>is_positively_graded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_positively_graded(R::MPolyDecRing)</code></pre><p>Return <code>true</code> if <code>R</code> is positively graded, <code>false</code> otherwise.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We say that <code>R</code> is <em>positively graded</em> by a finitely generated abelian group <span>$G$</span> if the coefficient ring of <code>R</code> is a field,  <span>$G$</span> is free, and each graded part <span>$R_g$</span>, <span>$g\in G$</span>, has finite dimension.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S, (t, x, y) = graded_polynomial_ring(QQ, [&quot;t&quot;, &quot;x&quot;, &quot;y&quot;]; weights = [-1, 1, 1])
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[t, x, y])

julia&gt; is_positively_graded(S)
false

julia&gt; G = abelian_group([0, 2])
(General) abelian group with relation matrix
[0 0; 0 2]

julia&gt; W = [gen(G, 1)+gen(G, 2), gen(G, 1)]
2-element Vector{GrpAbFinGenElem}:
 Element of G with components [1 1]
 Element of G with components [1 0]

julia&gt; S, (x, y) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;]; weights = W)
(Graded multivariate polynomial ring in 2 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y])

julia&gt; is_positively_graded(S)
false</code></pre></div></section></article><h2 id="Data-Associated-to-Multivariate-Rings"><a class="docs-heading-anchor" href="#Data-Associated-to-Multivariate-Rings">Data Associated to Multivariate Rings</a><a id="Data-Associated-to-Multivariate-Rings-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Associated-to-Multivariate-Rings" title="Permalink"></a></h2><p>Given a multivariate polynomial ring <code>R</code> with coefficient ring <code>C</code>,</p><ul><li><code>coefficient_ring(R)</code> refers to <code>C</code>,</li><li><code>gens(R)</code> to the generators (variables) of <code>R</code>,</li><li><code>ngens(R)</code> to the number of these generators, and</li><li><code>gen(R, i)</code> as well as <code>R[i]</code> to the <code>i</code>-th such generator.</li></ul><h6 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; coefficient_ring(R)
Rational field

julia&gt; gens(R)
3-element Vector{QQMPolyRingElem}:
 x
 y
 z

julia&gt; gen(R, 2)
y

julia&gt; R[3]
z

julia&gt; ngens(R)
3
</code></pre><p>In the graded case, we additionally have:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="grading_group-Tuple{MPolyDecRing}" href="#grading_group-Tuple{MPolyDecRing}"><code>grading_group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grading_group(R::MPolyDecRing)</code></pre><p>If <code>R</code> is, say, <code>G</code>-graded, then return <code>G</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3])
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])

julia&gt; grading_group(R)
GrpAb: Z</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="monomial_basis-Tuple{MPolyDecRing, GrpAbFinGenElem}" href="#monomial_basis-Tuple{MPolyDecRing, GrpAbFinGenElem}"><code>monomial_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">monomial_basis(R::MPolyDecRing, g::GrpAbFinGenElem)</code></pre><p>Given a polynomial ring <code>R</code> over a field which is graded by a free group of type <code>GrpAbFinGen</code>, and given an element <code>g</code> of that group, return the monomials of degree <code>g</code> in <code>R</code>.</p><pre><code class="nohighlight hljs">monomial_basis(R::MPolyDecRing, W::Vector{&lt;:IntegerUnion})</code></pre><p>Given a <span>$\mathbb  Z^m$</span>-graded polynomial ring <code>R</code> over a field and a vector <code>W</code> of <span>$m$</span> integers, convert <code>W</code> into an element <code>g</code> of the grading group of <code>R</code> and proceed as above.</p><pre><code class="nohighlight hljs">monomial_basis(R::MPolyDecRing, d::IntegerUnion)</code></pre><p>Given a <span>$\mathbb  Z$</span>-graded polynomial ring <code>R</code> over a field and an integer <code>d</code>, convert <code>d</code> into an element <code>g</code> of the grading group of <code>R</code> and proceed as above.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the component of the given degree is not finite dimensional, an error message will be thrown.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; T, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]);

julia&gt; G = grading_group(T)
GrpAb: Z

julia&gt; L = monomial_basis(T, 2)
6-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:
 z^2
 y*z
 y^2
 x*z
 x*y
 x^2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="homogeneous_component-Tuple{MPolyDecRing, GrpAbFinGenElem}" href="#homogeneous_component-Tuple{MPolyDecRing, GrpAbFinGenElem}"><code>homogeneous_component</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogeneous_component(R::MPolyDecRing, g::GrpAbFinGenElem)</code></pre><p>Given a polynomial ring <code>R</code> over a field which is graded by a free group of type <code>GrpAbFinGen</code>, and given an element <code>g</code> of that group, return the homogeneous component of <code>R</code> of degree <code>g</code> as a standard vector space. Additionally, return the map which sends an element of that vector space to the corresponding monomial in <code>R</code>.</p><pre><code class="nohighlight hljs">homogeneous_component(R::MPolyDecRing, W::Vector{&lt;:IntegerUnion})</code></pre><p>Given a <span>$\mathbb  Z^m$</span>-graded polynomial ring <code>R</code> over a field, and given a vector <code>W</code> of <span>$m$</span> integers, convert <code>W</code> into an element <code>g</code> of the grading group of <code>R</code> and proceed as above.</p><pre><code class="nohighlight hljs">homogeneous_component(R::MPolyDecRing, d::IntegerUnion)</code></pre><p>Given a <span>$\mathbb  Z$</span>-graded polynomial ring <code>R</code> over a field, and given an integer <code>d</code>, convert <code>d</code> into an element <code>g</code> of the grading group of <code>R</code> proceed as above.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the component is not finite dimensional, an error message will be thrown.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; W = [1 1 0 0 0; 0 0 1 1 1]
2×5 Matrix{Int64}:
 1  1  0  0  0
 0  0  1  1  1

julia&gt; S, _ = graded_polynomial_ring(QQ, &quot;x&quot; =&gt; 1:2, &quot;y&quot; =&gt; 1:3; weights = W);

julia&gt; G = grading_group(S)
GrpAb: Z^2

julia&gt; L = homogeneous_component(S, [1, 1]);

julia&gt; L[1]
homogeneous component of graded multivariate polynomial ring in 5 variables over QQ of degree [1 1]

julia&gt; FG = gens(L[1]);

julia&gt; EMB = L[2]
Map defined by a julia-function with inverse
  from s_[1 1] of dim 6
  to graded multivariate polynomial ring in 5 variables over QQ

julia&gt; for i in 1:length(FG) println(EMB(FG[i])) end
x[2]*y[3]
x[2]*y[2]
x[2]*y[1]
x[1]*y[3]
x[1]*y[2]
x[1]*y[1]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="forget_grading-Tuple{MPolyDecRing}" href="#forget_grading-Tuple{MPolyDecRing}"><code>forget_grading</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forget_grading(R::MPolyDecRing)</code></pre><p>Return the ungraded undecorated ring.</p></div></section></article><h2 id="Elements-of-Multivariate-Rings"><a class="docs-heading-anchor" href="#Elements-of-Multivariate-Rings">Elements of Multivariate Rings</a><a id="Elements-of-Multivariate-Rings-1"></a><a class="docs-heading-anchor-permalink" href="#Elements-of-Multivariate-Rings" title="Permalink"></a></h2><h3 id="Constructors-2"><a class="docs-heading-anchor" href="#Constructors-2">Constructors</a><a class="docs-heading-anchor-permalink" href="#Constructors-2" title="Permalink"></a></h3><p>One way to create elements of a multivariate  polynomial ring is to build up polynomials from the generators (variables) of the ring using basic arithmetic as shown below:</p><h6 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; f = 3*x^2+y*z
3*x^2 + y*z

julia&gt; typeof(f)
QQMPolyRingElem

julia&gt; S, (x, y, z) = grade(R)
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])

julia&gt; g = 3*x^2+y*z
3*x^2 + y*z

julia&gt; typeof(g)
MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}

julia&gt; g == S(f)
true
</code></pre><p>Alternatively, there is the following constructor:</p><pre><code class="language- hljs">(R::MPolyRing{T})(c::Vector{T}, e::Vector{Vector{Int}}) where T &lt;: RingElem</code></pre><p>Its return value is the element of  <code>R</code>  whose nonzero coefficients are specified by the elements of <code>c</code>, with exponent vectors given by the elements of <code>e</code>.</p><h6 id="Examples-4"><a class="docs-heading-anchor" href="#Examples-4">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-4" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;])
(Multivariate polynomial ring in 3 variables over QQ, QQMPolyRingElem[x, y, z])

julia&gt; f = 3*x^2+y*z
3*x^2 + y*z

julia&gt; g = R(QQ.([3, 1]), [[2, 0, 0], [0, 1, 1]])
3*x^2 + y*z

julia&gt; f == g
true
</code></pre><p>An often more effective way to create polynomials is to use the <code>MPoly</code> build context as indicated below:</p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over QQ, QQMPolyRingElem[x, y])

julia&gt; B = MPolyBuildCtx(R)
Builder for an element of Multivariate polynomial ring in 2 variables over QQ

julia&gt; for i = 1:5 push_term!(B, QQ(i), [i, i-1]) end

julia&gt; finish(B)
5*x^5*y^4 + 4*x^4*y^3 + 3*x^3*y^2 + 2*x^2*y + x
</code></pre><h3 id="Special-Elements"><a class="docs-heading-anchor" href="#Special-Elements">Special Elements</a><a id="Special-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Elements" title="Permalink"></a></h3><p>Given a multivariate polynomial ring <code>R</code>, <code>zero(R)</code> and <code>one(R)</code> refer to the additive and multiplicative identity of <code>R</code>, respectively. Relevant test calls on an element <code>f</code> of <code>R</code> are  <code>iszero(f)</code> and <code>isone(f)</code>.</p><h3 id="Data-Associated-to-Elements-of-Multivariate-Rings"><a class="docs-heading-anchor" href="#Data-Associated-to-Elements-of-Multivariate-Rings">Data Associated to Elements of Multivariate Rings</a><a id="Data-Associated-to-Elements-of-Multivariate-Rings-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Associated-to-Elements-of-Multivariate-Rings" title="Permalink"></a></h3><p>Given an element <code>f</code> of a multivariate polynomial ring <code>R</code> or a graded version of such a ring, </p><ul><li><code>parent(f)</code> refers to <code>R</code>, and</li><li><code>total_degree(f)</code> to the total degree of <code>f</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Given a set of variables <span>$x = \{x_1, \ldots, x_n\}$</span>, the <em>total degree</em> of a monomial <span>$x^\alpha=x_1^{\alpha_1}\cdots x_n^{\alpha_n}\in\text{Mon}_n(x)$</span> is the sum of the <span>$\alpha_i$</span>. The <em>total degree</em> of a polynomial <code>f</code>  is the maximum of the total degrees of its monomials. In particular, the notion of total degree ignores the weights given to the variables in the graded case.</p></div></div><p>For iterators which allow one to recover the monomials  (terms, <span>$\dots$</span>) of <code>f</code> we refer to the subsection <em>Monomials, Terms, and More</em> of the section on <em>Gröbner/Standard Bases</em>.</p><h6 id="Examples-5"><a class="docs-heading-anchor" href="#Examples-5">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-5" title="Permalink"></a></h6><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y) = polynomial_ring(GF(5), [&quot;x&quot;, &quot;y&quot;])
(Multivariate polynomial ring in 2 variables over GF(5), fpMPolyRingElem[x, y])

julia&gt; c = map(GF(5), [1, 2, 3])
3-element Vector{fpFieldElem}:
 1
 2
 3

julia&gt; e = [[3, 2], [1, 0], [0, 1]]
3-element Vector{Vector{Int64}}:
 [3, 2]
 [1, 0]
 [0, 1]

julia&gt; f = R(c, e)
x^3*y^2 + 2*x + 3*y

julia&gt; parent(f)
Multivariate polynomial ring in 2 variables x, y
  over finite field of characteristic 5

julia&gt; total_degree(f)
5</code></pre><p>Further functionality is available in the graded case:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="homogeneous_components-Union{Tuple{MPolyDecRingElem{T, S}}, Tuple{S}, Tuple{T}} where {T, S}" href="#homogeneous_components-Union{Tuple{MPolyDecRingElem{T, S}}, Tuple{S}, Tuple{T}} where {T, S}"><code>homogeneous_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogeneous_components(f::MPolyDecRingElem{T, S}) where {T, S}</code></pre><p>Given an element <code>f</code> of a graded multivariate ring, return the homogeneous components of <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3])
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])

julia&gt; f = x^2+y+z
x^2 + y + z

julia&gt; homogeneous_components(f)
Dict{GrpAbFinGenElem, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}} with 2 entries:
  [2] =&gt; x^2 + y
  [3] =&gt; z

julia&gt; G = abelian_group([0, 0, 2, 2])
(General) abelian group with relation matrix
[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]

julia&gt; W = [G[1]+G[3]+G[4], G[2]+G[4], G[1]+G[3], G[2], G[1]+G[2]];

julia&gt; S, x = graded_polynomial_ring(QQ, &quot;x&quot; =&gt; 1:5; weights=W)
(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4], x[5]])

julia&gt; f = x[1]^2+x[3]^2+x[5]^2
x[1]^2 + x[3]^2 + x[5]^2

julia&gt; homogeneous_components(f)
Dict{GrpAbFinGenElem, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}} with 2 entries:
  [2 2 0 0] =&gt; x[5]^2
  [2 0 0 0] =&gt; x[1]^2 + x[3]^2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="homogeneous_component-Tuple{MPolyDecRingElem, GrpAbFinGenElem}" href="#homogeneous_component-Tuple{MPolyDecRingElem, GrpAbFinGenElem}"><code>homogeneous_component</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">homogeneous_component(f::MPolyDecRingElem, g::GrpAbFinGenElem)</code></pre><p>Given an element <code>f</code> of a graded multivariate ring, and given an element  <code>g</code> of the grading group of that ring, return the homogeneous component of <code>f</code> of degree <code>g</code>.</p><pre><code class="nohighlight hljs">homogeneous_component(f::MPolyDecRingElem, g::Vector{&lt;:IntegerUnion})</code></pre><p>Given an element <code>f</code> of a <span>$\mathbb  Z^m$</span>-graded multivariate ring <code>R</code>, say, and given a vector <code>g</code> of <span>$m$</span> integers, convert <code>g</code> into an element of the grading group of <code>R</code>, and return the homogeneous component of <code>f</code> whose degree is that element.</p><pre><code class="nohighlight hljs">homogeneous_component(f::MPolyDecRingElem, g::IntegerUnion)</code></pre><p>Given an element <code>f</code> of a <span>$\mathbb  Z$</span>-graded multivariate ring <code>R</code>, say, and given an integer <code>g</code>, convert <code>g</code> into an element of the grading group of <code>R</code>, and return the  homogeneous component of <code>f</code> whose degree is that element.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = abelian_group([0, 0, 2, 2])
(General) abelian group with relation matrix
[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]

julia&gt; W = [G[1]+G[3]+G[4], G[2]+G[4], G[1]+G[3], G[2], G[1]+G[2]];

julia&gt; S, x = graded_polynomial_ring(QQ, &quot;x&quot; =&gt; 1:5; weights=W)
(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4], x[5]])

julia&gt; f = x[1]^2+x[3]^2+x[5]^2
x[1]^2 + x[3]^2 + x[5]^2

julia&gt; homogeneous_component(f, 2*G[1])
x[1]^2 + x[3]^2

julia&gt; W = [[1, 0], [0, 1], [1, 0], [4, 1]]
4-element Vector{Vector{Int64}}:
 [1, 0]
 [0, 1]
 [1, 0]
 [4, 1]

julia&gt; R, x = graded_polynomial_ring(QQ, :x =&gt; 1:4; weights=W)
(Graded multivariate polynomial ring in 4 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4]])

julia&gt; f = x[1]^2*x[2]+x[4]
x[1]^2*x[2] + x[4]

julia&gt; homogeneous_component(f, [2, 1])
x[1]^2*x[2]

julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]; weights=[1, 2, 3])
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])

julia&gt; f = x^2+y+z
x^2 + y + z

julia&gt; homogeneous_component(f, 1)
0

julia&gt; homogeneous_component(f, 2)
x^2 + y

julia&gt; homogeneous_component(f, 3)
z</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_homogeneous-Tuple{MPolyDecRingElem}" href="#is_homogeneous-Tuple{MPolyDecRingElem}"><code>is_homogeneous</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_homogeneous(f::MPolyDecRingElem)</code></pre><p>Given an element <code>f</code> of a graded multivariate ring, return <code>true</code> if <code>f</code> is homogeneous, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3])
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])

julia&gt; f = x^2+y*z
x^2 + y*z

julia&gt; is_homogeneous(f)
false

julia&gt; W = [1 2 1 0; 3 4 0 1]
2×4 Matrix{Int64}:
 1  2  1  0
 3  4  0  1

julia&gt; S, (w, x, y, z) = graded_polynomial_ring(QQ, [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], W)
(Graded multivariate polynomial ring in 4 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[w, x, y, z])

julia&gt; F = w^3*y^3*z^3 + w^2*x*y^2*z^2 + w*x^2*y*z + x^3
w^3*y^3*z^3 + w^2*x*y^2*z^2 + w*x^2*y*z + x^3

julia&gt; is_homogeneous(F)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="degree-Tuple{MPolyDecRingElem}" href="#degree-Tuple{MPolyDecRingElem}"><code>degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree(f::MPolyDecRingElem)</code></pre><p>Given a homogeneous element <code>f</code> of a graded multivariate ring, return the degree of <code>f</code>.</p><pre><code class="nohighlight hljs">degree(::Type{Vector{Int}}, f::MPolyDecRingElem)</code></pre><p>Given a homogeneous element <code>f</code> of a <span>$\mathbb Z^m$</span>-graded multivariate ring, return the degree of <code>f</code>, converted to a vector of integer numbers.</p><pre><code class="nohighlight hljs">degree(::Type{Int}, f::MPolyDecRingElem)</code></pre><p>Given a homogeneous element <code>f</code> of a <span>$\mathbb Z$</span>-graded multivariate ring, return the degree of <code>f</code>, converted to an integer number.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = abelian_group([0, 0, 2, 2])
(General) abelian group with relation matrix
[0 0 0 0; 0 0 0 0; 0 0 2 0; 0 0 0 2]

julia&gt; W = [G[1]+G[3]+G[4], G[2]+G[4], G[1]+G[3], G[2], G[1]+G[2]];

julia&gt; S, x = graded_polynomial_ring(QQ, &quot;x&quot; =&gt; 1:5; weights=W)
(Graded multivariate polynomial ring in 5 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4], x[5]])

julia&gt; f = x[2]^2+2*x[4]^2
x[2]^2 + 2*x[4]^2

julia&gt; degree(f)
Element of G with components [0 2 0 0]

julia&gt; W = [[1, 0], [0, 1], [1, 0], [4, 1]]
4-element Vector{Vector{Int64}}:
 [1, 0]
 [0, 1]
 [1, 0]
 [4, 1]

julia&gt; R, x = graded_polynomial_ring(QQ, [&quot;x[1]&quot;, &quot;x[2]&quot;, &quot;x[3]&quot;, &quot;x[4]&quot;], W)
(Graded multivariate polynomial ring in 4 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x[1], x[2], x[3], x[4]])

julia&gt; f = x[1]^4*x[2]+x[4]
x[1]^4*x[2] + x[4]

julia&gt; degree(f)
[4 1]

julia&gt; degree(Vector{Int}, f)
2-element Vector{Int64}:
 4
 1

julia&gt;  R, (x, y, z) = graded_polynomial_ring(QQ, [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], [1, 2, 3])
(Graded multivariate polynomial ring in 3 variables over QQ, MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}[x, y, z])

julia&gt; f = x^6+y^3+z^2
x^6 + y^3 + z^2

julia&gt; degree(f)
[6]

julia&gt; typeof(degree(f))
GrpAbFinGenElem

julia&gt; degree(Int, f)
6

julia&gt; typeof(degree(Int, f))
Int64</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="forget_grading-Tuple{MPolyDecRingElem}" href="#forget_grading-Tuple{MPolyDecRingElem}"><code>forget_grading</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forget_grading(f::MPolyDecRingElem)</code></pre><p>Return the element in the underlying ungraded ring.</p></div></section></article><h2 id="Homomorphisms-From-Multivariate-Rings"><a class="docs-heading-anchor" href="#Homomorphisms-From-Multivariate-Rings">Homomorphisms From Multivariate Rings</a><a id="Homomorphisms-From-Multivariate-Rings-1"></a><a class="docs-heading-anchor-permalink" href="#Homomorphisms-From-Multivariate-Rings" title="Permalink"></a></h2><p>If <span>$R$</span> is a multivariate polynomial ring, and <span>$S$</span> is any ring, then a ring homomorphism <span>$R \to S$</span> is determined by specifying its restriction to the coefficient ring of <span>$R$</span>, and by assigning an image to each variable of <span>$R$</span>. In OSCAR, such homomorphisms are created by using the following constructor:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="hom-Tuple{MPolyRing, NCRing, Any, Vector}" href="#hom-Tuple{MPolyRing, NCRing, Any, Vector}"><code>hom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hom(R::MPolyRing, S::NCRing, coeff_map, images::Vector; check::Bool = true)

hom(R::MPolyRing, S::NCRing, images::Vector; check::Bool = true)</code></pre><p>Given a homomorphism <code>coeff_map</code> from <code>C</code> to <code>S</code>, where <code>C</code> is the  coefficient ring of <code>R</code>, and given a vector <code>images</code> of <code>nvars(R)</code>  elements of <code>S</code>, return the homomorphism <code>R</code> <span>$\to$</span> <code>S</code> whose restriction  to <code>C</code> is <code>coeff_map</code>, and which sends the <code>i</code>-th variable of <code>R</code> to the  <code>i</code>-th entry of <code>images</code>.</p><p>If no coefficient map is entered, invoke a canonical homomorphism of <code>C</code> to <code>S</code>, if such a homomorphism exists, and throw an error, otherwise.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In case <code>check = true</code> (default), the function checks the conditions below:</p><ul><li>If <code>S</code> is graded, the assigned images must be homogeneous with respect to the given grading.</li><li>If <code>S</code> is noncommutative, the assigned images must pairwise commute. </li></ul></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; K, a = finite_field(2, 2, &quot;a&quot;);

julia&gt; R, (x, y) = polynomial_ring(K, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; F = hom(R, R, z -&gt; z^2, [y, x])
Ring homomorphism
  from multivariate polynomial ring in 2 variables over GF(2^2)
  to multivariate polynomial ring in 2 variables over GF(2^2)
defined by
  x -&gt; y
  y -&gt; x
with map on coefficients
  #1

julia&gt; F(a * y)
(a + 1)*x

julia&gt; Qi, i = quadratic_field(-1)
(Imaginary quadratic field defined by x^2 + 1, sqrt(-1))

julia&gt; S, (x, y) = polynomial_ring(Qi, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; G = hom(S, S, hom(Qi, Qi, -i), [x^2, y^2])
Ring homomorphism
  from multivariate polynomial ring in 2 variables over imaginary quadratic field defined by x^2 + 1
  to multivariate polynomial ring in 2 variables over imaginary quadratic field defined by x^2 + 1
defined by
  x -&gt; x^2
  y -&gt; y^2
with map on coefficients
  Map: imaginary quadratic field defined by x^2 + 1 -&gt; imaginary quadratic field defined by x^2 + 1

julia&gt; G(x+i*y)
x^2 - sqrt(-1)*y^2

julia&gt; R, (x, y) = polynomial_ring(ZZ, [&quot;x&quot;, &quot;y&quot;]);

julia&gt; f = 3*x^2+2*x+1;

julia&gt; S, (x, y) = polynomial_ring(GF(2), [&quot;x&quot;, &quot;y&quot;]);

julia&gt; H = hom(R, S, gens(S))
Ring homomorphism
  from multivariate polynomial ring in 2 variables over ZZ
  to multivariate polynomial ring in 2 variables over GF(2)
defined by
  x -&gt; x
  y -&gt; y

julia&gt; H(f)
x^2 + 1</code></pre></div></section></article><p>Given a ring homomorphism <code>F</code> from <code>R</code> to <code>S</code> as above, <code>domain(F)</code> and <code>codomain(F)</code> refer to <code>R</code> and <code>S</code>, respectively.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The OSCAR homomorphism type <code>AffAlgHom</code> models ring homomorphisms <code>R</code> <span>$\to$</span> <code>S</code> such that the type of both <code>R</code> and <code>S</code>  is a subtype of <code>Union{MPolyRing{T}, MPolyQuoRing{U}}</code>, where <code>T &lt;: FieldElem</code> and <code>U &lt;: MPolyRingElem{T}</code>. Functionality for these homomorphism is discussed in the section on affine algebras.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Introduction</a><a class="docs-footer-nextpage" href="../ideals/">Ideals in Multivariate Rings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 5 December 2023 17:43">Tuesday 5 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
