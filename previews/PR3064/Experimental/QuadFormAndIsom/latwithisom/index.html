<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lattices with isometry · Oscar.jl</title><meta name="title" content="Lattices with isometry · Oscar.jl"/><meta property="og:title" content="Lattices with isometry · Oscar.jl"/><meta property="twitter:title" content="Lattices with isometry · Oscar.jl"/><meta name="description" content="Documentation for Oscar.jl."/><meta property="og:description" content="Documentation for Oscar.jl."/><meta property="twitter:description" content="Documentation for Oscar.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="Oscar.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Oscar.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome to OSCAR</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">General</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../General/architecture/">Architecture</a></li><li><a class="tocitem" href="../../../General/other/">Notes for users of other computer algebra systems</a></li><li><a class="tocitem" href="../../../General/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../../General/serialization/">Serialization</a></li><li><a class="tocitem" href="../../../General/complex/">Complex Algorithms in OSCAR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Groups</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Groups/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Groups/basics/">Basics</a></li><li><a class="tocitem" href="../../../Groups/subgroups/">Subgroups</a></li><li><a class="tocitem" href="../../../Groups/quotients/">Quotients</a></li><li><a class="tocitem" href="../../../Groups/products/">Products of groups</a></li><li><a class="tocitem" href="../../../Groups/permgroup/">Permutation groups</a></li><li><a class="tocitem" href="../../../Groups/fpgroup/">Finitely presented groups</a></li><li><a class="tocitem" href="../../../Groups/pcgroup/">Polycyclic groups</a></li><li><a class="tocitem" href="../../../Groups/matgroup/">Matrix groups</a></li><li><a class="tocitem" href="../../../Groups/action/">Group Actions</a></li><li><a class="tocitem" href="../../../Groups/grouphom/">Group homomorphisms</a></li><li><a class="tocitem" href="../../../Groups/autgroup/">Groups of automorphisms</a></li><li><a class="tocitem" href="../../../Groups/grouplib/">Group libraries</a></li><li><a class="tocitem" href="../../../Hecke/abelian/introduction/">Abelian Groups</a></li><li><a class="tocitem" href="../../../Groups/group_characters/">Group characters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Rings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/ring/">Ring functionality</a></li><li><a class="tocitem" href="../../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/polynomial/">Univariate polynomial functionality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/mpolynomial/">Sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/series/">Power series</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../../Nemo/series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../../Nemo/puiseux/">Puiseux series</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/field/">Field functionality</a></li><li><a class="tocitem" href="../../../Rings/rational/">Rationals</a></li><li><a class="tocitem" href="../../../Hecke/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../../Hecke/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-5-7" type="checkbox"/><label class="tocitem" for="menuitem-5-7"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Nemo/padic/">Padics</a></li><li><a class="tocitem" href="../../../Nemo/qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../../Nemo/finitefield/">Finite fields</a></li><li><a class="tocitem" href="../../../Fields/algebraic_closure_fp/">Algebraic closure of finite prime fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Linear Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../LinearAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix/">Matrix functionality</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-6-5" type="checkbox"/><label class="tocitem" for="menuitem-6-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AbstractAlgebra/module/">Finitely presented modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/submodule/">Submodules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../../AbstractAlgebra/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-6" type="checkbox"/><label class="tocitem" for="menuitem-6-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/basics/">Spaces</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/lattices/">Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/genusherm/">Genera for hermitian lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/integer_lattices/">Integer Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/Zgenera/">Genera of Integer Lattices</a></li><li><a class="tocitem" href="../../../Hecke/quad_forms/discriminant_group/">Discriminant Groups</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Number Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NumberTheory/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/number_fields/intro/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/fields/">Number field operations</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/elements/">Element operations</a></li><li><a class="tocitem" href="../../../Hecke/number_fields/internal/">Internals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Hecke/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../Hecke/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../../Hecke/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../../Hecke/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../../Hecke/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><a class="tocitem" href="../../../NumberTheory/abelian_closure/">Abelian closure of the rationals</a></li><li><a class="tocitem" href="../../../NumberTheory/galois/">Galois Theory</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Polyhedra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/constructions/">Constructions</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/polymake/"><code>Polyhedron</code> and <code>polymake</code>&#39;s <code>Polytope</code></a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/Polyhedra/auxiliary/">Auxiliary functions</a></li></ul></li><li><a class="tocitem" href="../../../PolyhedralGeometry/cones/">Cones</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/fans/">Polyhedral Fans</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/polyhedral_complexes/">Polyhedral Complexes</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/linear_programs/">Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/mixed_integer_linear_programs/">Mixed Integer Linear Programs</a></li><li><a class="tocitem" href="../../../PolyhedralGeometry/subdivisions_of_points/">Subdivisions of Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Commutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/intro/">Introduction</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/rings/">Creating Multivariate Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ideals/">Ideals in Multivariate Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/affine_algebras/">Affine Algebras and Their Ideals</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/localizations/">Localized Rings and Their Ideals</a></li><li><input class="collapse-toggle" id="menuitem-9-6" type="checkbox"/><label class="tocitem" for="menuitem-9-6"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/intro/">Introduction</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/free_modules/">Free Modules</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/subquotients/">Subquotients</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/module_operations/">Operations on Modules</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/hom_operations/">Operations on Module Maps</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/ModulesOverMultivariateRings/complexes/">Chain and Cochain Complexes</a></li></ul></li><li><a class="tocitem" href="../../../CommutativeAlgebra/homological_algebra/">Homological Algebra</a></li><li><input class="collapse-toggle" id="menuitem-9-8" type="checkbox"/><label class="tocitem" for="menuitem-9-8"><span class="docs-label">Gröbner/Standard Bases</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/orderings/">Monomial Orderings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/groebner_bases/">Gröbner/Standard Bases Over Fields</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/GroebnerBases/groebner_bases_integers/">Gröbner/Standard Bases Over <span>$\mathbb Z$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-9" type="checkbox"/><label class="tocitem" for="menuitem-9-9"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/Miscellaneous/binomial_ideals/">Binomial Primary Decomposition</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9-10" type="checkbox"/><label class="tocitem" for="menuitem-9-10"><span class="docs-label">Frameworks for Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../CommutativeAlgebra/FrameWorks/ring_localizations/">A Framework for Localizing Rings</a></li><li><a class="tocitem" href="../../../CommutativeAlgebra/FrameWorks/module_localizations/">Localizations of modules over computable rings</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Invariant Theory</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../InvariantTheory/intro/">Introduction</a></li><li><a class="tocitem" href="../../../InvariantTheory/finite_groups/">Invariants of Finite Groups</a></li><li><a class="tocitem" href="../../../InvariantTheory/reductive_groups/">Invariants of Linearly Reductive Groups</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">Algebraic Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Schemes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/GeneralSchemes/">General schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/AffineSchemes/">Affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/MorphismsOfAffineSchemes/">Morphisms of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/ArchitectureOfAffineSchemes/">Architecture of affine schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveredSchemes/">Covered schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveringsAndGlueings/">Coverings</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/CoveredSchemeMorphisms/">Morphisms of covered schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/ProjectiveSchemes/">Projective schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Schemes/MorphismsOfProjectiveSchemes/">Morphisms of projective schemes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Algebraic Sets</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicSets/AffineAlgebraicSet/">Affine Algebraic Sets</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicSets/ProjectiveAlgebraicSet/">Projective Algebraic Sets</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-4" type="checkbox"/><label class="tocitem" for="menuitem-11-4"><span class="docs-label">Algebraic Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicVarieties/AffineVariety/">Affine Varieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/AlgebraicVarieties/ProjectiveVariety/">Projective Varieties</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-5" type="checkbox"/><label class="tocitem" for="menuitem-11-5"><span class="docs-label">Rational Points</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/RationalPoints/Affine/">Affine</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/RationalPoints/Projective/">Projective</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-6" type="checkbox"/><label class="tocitem" for="menuitem-11-6"><span class="docs-label">Toric Varieties</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/intro/">Introduction</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/NormalToricVarieties/">Normal Toric Varieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CyclicQuotientSingularities/">Cyclic Quotient Singularities</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisors/">Toric Divisors</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricDivisorClasses/">Toric Divisor Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricLineBundles/">Toric Line Bundles</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/cohomCalg/">Line bundle cohomology with cohomCalg</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/CohomologyClasses/">Cohomology Classes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/Subvarieties/">Subvarieties</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/AlgebraicCycles/">The Chow ring</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricMorphisms/">ToricMorphisms</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricSchemes/">Toric Schemes</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/ToricIdealSheaves/">Toric Ideal Sheaves (Experimental)</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/ToricVarieties/BlowdownMorphisms/">Toric Blowdown Morphisms (Experimental)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-7" type="checkbox"/><label class="tocitem" for="menuitem-11-7"><span class="docs-label">Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/AffinePlaneCurves/">Affine plane curves</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/ProjectiveCurves/">Projective Curves</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Curves/ProjectivePlaneCurves/">Projective Plane Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-8" type="checkbox"/><label class="tocitem" for="menuitem-11-8"><span class="docs-label">Surfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/K3Surfaces/">Automorphism Groups of  K3 surfaces</a></li><li><a class="tocitem" href="../../../AlgebraicGeometry/Surfaces/SurfacesP4/">Nongeneral Type Surfaces in <span>$\mathbb P^4$</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-9" type="checkbox"/><label class="tocitem" for="menuitem-11-9"><span class="docs-label">Miscellaneous</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../AlgebraicGeometry/Miscellaneous/miscellaneous/">Some Special Ideals</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Noncommutative Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/intro/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-12-2" type="checkbox"/><label class="tocitem" for="menuitem-12-2"><span class="docs-label">PBW-Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/intro/">Introduction</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/creation/">Creating PBW-Algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/ideals/">Ideals in PBW-algebras</a></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/PBWAlgebras/quotients/">GR-Algebras: Quotients of PBW-Algebras</a></li></ul></li><li><a class="tocitem" href="../../../NoncommutativeAlgebra/free_associative_algebra/">Free Associative Algebras</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">Combinatorics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../Combinatorics/graphs/">Graphs</a></li><li><a class="tocitem" href="../../../Combinatorics/matroids/">Matroids</a></li><li><a class="tocitem" href="../../../Combinatorics/simplicialcomplexes/">Simplicial Complexes</a></li><li><a class="tocitem" href="../../../Combinatorics/partitions/">Partitions</a></li><li><a class="tocitem" href="../../../Combinatorics/tableaux/">Tableaux</a></li><li><a class="tocitem" href="../../../Combinatorics/schur_polynomials/">Schur polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">Straight Line Programs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../StraightLinePrograms/intro/">Introduction</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/gapslps/">GAP&#39;s SLPs</a></li><li><a class="tocitem" href="../../../StraightLinePrograms/abstractalgebra/">AbstractAlgebra&#39;s polynomial interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">Tropical Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../TropicalGeometry/intro/">Introduction</a></li><li><a class="tocitem" href="../../../TropicalGeometry/semiring/">Tropical semirings, matrices, and polynomials</a></li><li><a class="tocitem" href="../../../TropicalGeometry/semiring_map/">Tropical semiring maps</a></li><li><a class="tocitem" href="../../../TropicalGeometry/variety/">Tropical varieties</a></li><li><a class="tocitem" href="../../../TropicalGeometry/hypersurface/">Tropical hypersurfaces</a></li><li><a class="tocitem" href="../../../TropicalGeometry/curve/">Tropical curves</a></li><li><a class="tocitem" href="../../../TropicalGeometry/linear_space/">Tropical linear spaces</a></li><li><a class="tocitem" href="../../../TropicalGeometry/groebner_theory/">Groebner theory</a></li><li><a class="tocitem" href="../../../TropicalGeometry/tropicalization/">Tropicalization of polynomial ideals</a></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li><li><a class="tocitem" href="../../../manualindex/">Index</a></li><li><input class="collapse-toggle" id="menuitem-18" type="checkbox"/><label class="tocitem" for="menuitem-18"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/new_developers/">Introduction for new developers</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/styleguide/">Developer Style Guide</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/documentation/">Documenting OSCAR code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/printing_details/">Details on printing in Oscar</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/debugging/">Debugging OSCAR Code</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/serialization/">Serialization</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/design_decisions/">Design Decisions</a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/gap_integration/">GAP Integration</a></li><li><input class="collapse-toggle" id="menuitem-18-9" type="checkbox"/><label class="tocitem" for="menuitem-18-9"><span class="docs-label">Polyhedral Geometry</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../DeveloperDocumentation/AbstractCollection/"><code>AbstractCollection</code></a></li><li><a class="tocitem" href="../../../DeveloperDocumentation/SubObjectIterator/"><code>SubObjectIterator</code></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-19" type="checkbox" checked/><label class="tocitem" for="menuitem-19"><span class="docs-label">Experimental</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro/">Adding new projects to experimental</a></li><li><input class="collapse-toggle" id="menuitem-19-2" type="checkbox"/><label class="tocitem" for="menuitem-19-2"><span class="docs-label">Bases for highest weight modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../BasisLieHighestWeight/introduction/">Introduction</a></li><li><a class="tocitem" href="../../BasisLieHighestWeight/user_functions/">User-facing functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-3" type="checkbox"/><label class="tocitem" for="menuitem-19-3"><span class="docs-label">Double complexes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../DoubleAndHyperComplexes/user_interface/">Double complexes – the user&#39;s interface</a></li><li><a class="tocitem" href="../../DoubleAndHyperComplexes/advice_for_the_programmer/">Advice for the programmer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-4" type="checkbox"/><label class="tocitem" for="menuitem-19-4"><span class="docs-label">F-Theory Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../FTheoryTools/introduction/">Welcome to FTheoryTools</a></li><li><a class="tocitem" href="../../FTheoryTools/weierstrass/">Weierstrass models</a></li><li><a class="tocitem" href="../../FTheoryTools/tate/">Global Tate models</a></li><li><a class="tocitem" href="../../FTheoryTools/hypersurface/">Hypersurface models</a></li><li><a class="tocitem" href="../../FTheoryTools/literature/">Literature constructions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-5" type="checkbox"/><label class="tocitem" for="menuitem-19-5"><span class="docs-label">Lie Algebras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LieAlgebras/introduction/">Introduction</a></li><li><a class="tocitem" href="../../LieAlgebras/lie_algebras/">Lie algebras</a></li><li><a class="tocitem" href="../../LieAlgebras/ideals_and_subalgebras/">Ideals and Lie subalgebras</a></li><li><a class="tocitem" href="../../LieAlgebras/lie_algebra_homs/">Lie algebra homomorphisms</a></li><li><a class="tocitem" href="../../LieAlgebras/modules/">Lie algebra modules</a></li><li><a class="tocitem" href="../../LieAlgebras/module_homs/">Lie algebra module homomorphisms</a></li><li><a class="tocitem" href="../../LieAlgebras/cartan_matrix/">Cartan Matrices</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-6" type="checkbox"/><label class="tocitem" for="menuitem-19-6"><span class="docs-label">Linear Quotients</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../LinearQuotients/introduction/">Introduction</a></li><li><a class="tocitem" href="../../LinearQuotients/linear_quotients/">Construction and basic functionality</a></li><li><a class="tocitem" href="../../LinearQuotients/cox_rings/">Cox rings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-7" type="checkbox"/><label class="tocitem" for="menuitem-19-7"><span class="docs-label">Matroid Realization Spaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../MatroidRealizationSpaces/introduction/">Matroid Realization Spaces</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-8" type="checkbox" checked/><label class="tocitem" for="menuitem-19-8"><span class="docs-label">Quadratic forms and isometries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../introduction/">Quadratic forms and isometries</a></li><li><a class="tocitem" href="../spacewithisom/">Quadratic spaces with isometry</a></li><li class="is-active"><a class="tocitem" href>Lattices with isometry</a><ul class="internal"><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Attributes-and-first-operations"><span>Attributes and first operations</span></a></li><li><a class="tocitem" href="#Type-for-finite-order-isometries"><span>Type for finite order isometries</span></a></li><li><a class="tocitem" href="#Hermitian-structures-and-trace-equivalence"><span>Hermitian structures and trace equivalence</span></a></li><li><a class="tocitem" href="#Discriminant-groups"><span>Discriminant groups</span></a></li><li><a class="tocitem" href="#Kernel-sublattices"><span>Kernel sublattices</span></a></li><li><a class="tocitem" href="#Signatures"><span>Signatures</span></a></li><li><a class="tocitem" href="#Equality"><span>Equality</span></a></li></ul></li><li><a class="tocitem" href="../enumeration/">Enumeration of isometries</a></li><li><a class="tocitem" href="../primembed/">Nikulin&#39;s theory on primitive embeddings</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-9" type="checkbox"/><label class="tocitem" for="menuitem-19-9"><span class="docs-label">Standard Finite Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../StandardFiniteFields/introduction/">-</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-19-10" type="checkbox"/><label class="tocitem" for="menuitem-19-10"><span class="docs-label">Orthogonal discriminants</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../OrthogonalDiscriminants/introduction/">Introduction</a></li><li><a class="tocitem" href="../../OrthogonalDiscriminants/access/">Access to precomputed OD data</a></li><li><a class="tocitem" href="../../OrthogonalDiscriminants/compute/">Criteria for computing orthogonal discriminants</a></li><li><a class="tocitem" href="../../OrthogonalDiscriminants/misc/">Miscellaneous functions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Experimental</a></li><li><a class="is-disabled">Quadratic forms and isometries</a></li><li class="is-active"><a href>Lattices with isometry</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lattices with isometry</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lattices-with-isometry"><a class="docs-heading-anchor" href="#Lattices-with-isometry">Lattices with isometry</a><a id="Lattices-with-isometry-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices-with-isometry" title="Permalink"></a></h1><p>We call <em>lattice with isometry</em> any pair <span>$(L, f)$</span> consisting of an integer lattice <span>$L$</span> together with an isometry <span>$f \in O(L)$</span>. We refer to the section about <a href="../../../Hecke/quad_forms/integer_lattices/#Integer-Lattices">Integer Lattices</a> of the documentation for new users.</p><p>In Oscar, such a pair is encoded in the type called <code>ZZLatWithIsom</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ZZLatWithIsom" href="#ZZLatWithIsom"><code>ZZLatWithIsom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ZZLatWithIsom</code></pre><p>A container type for pairs <span>$(L, f)$</span> consisting of an integer lattice <span>$L$</span> of type <code>ZZLat</code> and an isometry <span>$f$</span> given as a <code>QQMatrix</code> representing the action on the basis matrix of <span>$L$</span>.</p><p>We store the ambient space <span>$V$</span> of <span>$L$</span> together with an isometry <span>$f_a$</span> inducing <span>$f$</span> on <span>$L$</span> seen as a pair <span>$(V, f_a)$</span> of type <code>QuadSpaceWithIsom</code>. We moreover store the order <span>$n$</span> of <span>$f$</span>, which can be finite or infinite.</p><p>To construct an object of type <code>ZZLatWithIsom</code>, see the following examples:</p><p><strong>Examples</strong></p><p>One first way to construct such object, is by entering directly the lattice with an isometry. The isometry can be a honnest isometry of the lattice, or it can be an isometry of the ambient space preserving the lattice. Depending on this choice, one should enter the appropriate boolean value <code>ambient_representation</code>. This direct construction is done through the constructors <a href="#integer_lattice_with_isometry-Tuple{ZZLat, QQMatrix}"><code>integer_lattice_with_isometry</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:E, 6);

julia&gt; f = matrix(QQ, 6, 6, [ 1  2  3  2  1  1;
                             -1 -2 -2 -2 -1 -1;                                                
                              0  1  0  0  0  0;      
                              1  0  0  0  0  0;
                             -1 -1 -1  0  0 -1;
                              0  0  1  1  0  1]);

julia&gt; Lf = integer_lattice_with_isometry(L, f, ambient_representation = false)
Integer lattice of rank 6 and degree 6
  with isometry of finite order 8
  given by
  [ 1    2    3    2    1    1]
  [-1   -2   -2   -2   -1   -1]
  [ 0    1    0    0    0    0]
  [ 1    0    0    0    0    0]
  [-1   -1   -1    0    0   -1]
  [ 0    0    1    1    0    1]

julia&gt; B = matrix(QQ,1,6, [1   2   3   1   -1   3]);

julia&gt; I = lattice_in_same_ambient_space(L, B); # This is the invariant sublattice L^f

julia&gt; If = integer_lattice_with_isometry(I, ambient_isometry(Lf))
Integer lattice of rank 1 and degree 6
  with isometry of finite order 1
  given by
  [1]

julia&gt; integer_lattice_with_isometry(I, neg=true)
Integer lattice of rank 1 and degree 6
  with isometry of finite order 2
  given by
  [-1]</code></pre><p>Another way to construct such objects is to see them as sub-objects of their ambient space, of type <code>QuadSpaceWithIsom</code>. Through the constructors <code>lattice</code> and <code>lattice_in_same_ambient_space</code>, one can then construct lattices with isometry for free, in a given space, as long as the module they define is preserved by the fixed isometry of the ambient space.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = matrix(QQ, 6, 6 , [ 3 1 -1 1 0 0;
                               1 3  1 1 1 1;
                              -1 1  3 0 0 1;
                               1 1  0 4 2 2;
                               0 1  0 2 4 2;
                               0 1  1 2 2 4]);

julia&gt; V = quadratic_space(QQ, G);

julia&gt; f = matrix(QQ, 6, 6, [ 1 0  0 0 0  0
                              0 0 -1 0 0  0
                             -1 1 -1 0 0  0
                              0 0  0 1 0 -1
                              0 0  0 0 0 -1
                              0 0  0 0 1 -1]);

julia&gt; Vf = quadratic_space_with_isometry(V, f);

julia&gt; Lf = lattice(Vf)
Integer lattice of rank 6 and degree 6
  with isometry of finite order 3
  given by
  [ 1   0    0   0   0    0]
  [ 0   0   -1   0   0    0]
  [-1   1   -1   0   0    0]
  [ 0   0    0   1   0   -1]
  [ 0   0    0   0   0   -1]
  [ 0   0    0   0   1   -1]

julia&gt; B = matrix(QQ, 4, 6, [1 0 3 0 0 0;
                             0 1 1 0 0 0;
                             0 0 0 0 1 0;
                             0 0 0 0 0 1]);

julia&gt; Cf = lattice(Vf, B)  # coinvariant sublattice L_f
Integer lattice of rank 4 and degree 6
  with isometry of finite order 3
  given by
  [-2   3   0    0]
  [-1   1   0    0]
  [ 0   0   0   -1]
  [ 0   0   1   -1]

julia&gt; Cf2 = lattice_in_same_ambient_space(Lf, B)
Integer lattice of rank 4 and degree 6
  with isometry of finite order 3
  given by
  [-2   3   0    0]
  [-1   1   0    0]
  [ 0   0   0   -1]
  [ 0   0   1   -1]

julia&gt; Cf == Cf2
true</code></pre><p>The last equality of the last example shows why we care about <em>ambient context</em>: the two pairs of lattice with isometry <code>Cf</code> and <code>Cf2</code> are basically the same mathematical objects. Indeed, they lie in the same space, defines the same module and their respective isometries are induced by the same isometry of the ambient space. As for regular <code>ZZLat</code>, as soon as the lattices are in the same ambient space, we can compare them as <span>$\mathbb Z$</span>-modules, endowed with an isometry.</p></div></section></article><p>It is seen as a quadruple <span>$(Vf, L, f, n)$</span> where <span>$Vf = (V, f_a)$</span> consists of the ambient rational quadratic space <span>$V$</span> of <span>$L$</span> and an isometry <span>$f_a$</span> of <span>$V$</span> preserving <span>$L$</span> and inducing <span>$f$</span> on <span>$L$</span>. The integer <span>$n$</span> is the order of <span>$f$</span>, which is a divisor of the order of the isometry <span>$f_a\in O(V)$</span>.</p><p>Given a lattice with isometry <span>$(L, f)$</span>, we provide the following accessors to the elements of the previously described quadruple:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ambient_isometry-Tuple{ZZLatWithIsom}" href="#ambient_isometry-Tuple{ZZLatWithIsom}"><code>ambient_isometry</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ambient_isometry(Lf::ZZLatWithIsom) -&gt; QQMatrix</p><p>Given a lattice with isometry <span>$(L, f)$</span>, return an isometry of the ambient space of <span>$L$</span> inducing <span>$f$</span> on <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L; neg=true);

julia&gt; ambient_isometry(Lf)
[-1    0    0    0    0]
[ 0   -1    0    0    0]
[ 0    0   -1    0    0]
[ 0    0    0   -1    0]
[ 0    0    0    0   -1]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ambient_space-Tuple{ZZLatWithIsom}" href="#ambient_space-Tuple{ZZLatWithIsom}"><code>ambient_space</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ambient_space(Lf::ZZLatWithIsom) -&gt; QuadSpaceWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the pair <span>$(V, g)$</span> where <span>$V$</span> is the ambient quadratic space of <span>$L$</span> and <span>$g$</span> is an isometry of <span>$V$</span> inducing <span>$f$</span> on <span>$L$</span>.</p><p>Note that <span>$g$</span> might not be unique and we fix such a global isometry together with <span>$V$</span> into a container type <code>QuadSpaceWithIsom</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L; neg=true);

julia&gt; Vf = ambient_space(Lf)
Quadratic space of dimension 5
  with isometry of finite order 2
  given by
  [-1    0    0    0    0]
  [ 0   -1    0    0    0]
  [ 0    0   -1    0    0]
  [ 0    0    0   -1    0]
  [ 0    0    0    0   -1]

julia&gt; typeof(Vf)
QuadSpaceWithIsom</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="isometry-Tuple{ZZLatWithIsom}" href="#isometry-Tuple{ZZLatWithIsom}"><code>isometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isometry(Lf::ZZLatWithIsom) -&gt; QQMatrix</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the underlying isometry <span>$f$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L; neg=true);

julia&gt; isometry(Lf)
[-1    0    0    0    0]
[ 0   -1    0    0    0]
[ 0    0   -1    0    0]
[ 0    0    0   -1    0]
[ 0    0    0    0   -1]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="lattice-Tuple{ZZLatWithIsom}" href="#lattice-Tuple{ZZLatWithIsom}"><code>lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice(Lf::ZZLatWithIsom) -&gt; ZZLat</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the underlying lattice <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L; neg=true);

julia&gt; lattice(Lf) === L
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="order_of_isometry-Tuple{ZZLatWithIsom}" href="#order_of_isometry-Tuple{ZZLatWithIsom}"><code>order_of_isometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order_of_isometry(Lf::ZZLatWithIsom) -&gt; IntExt</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the order of the underlying isometry <span>$f$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L; neg=true);

julia&gt; order_of_isometry(Lf) == 2
true</code></pre></div></section></article><p>Note that for some computations, it is more convenient to work either with the isometry of the lattice itself, or with the fixed isometry of the ambient quadratic space inducing it on the lattice.</p><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><p>We provide two ways to construct a pair <span>$Lf = (L,f)$</span> consisting of an integer lattice endowed with an isometry. One way to construct an object of type <code>ZZLatWithIsom</code> is through the methods <code>integer_lattice_with_isometry</code>. These two methods do not require as input an ambient quadratic space with isometry.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="integer_lattice_with_isometry-Tuple{ZZLat, QQMatrix}" href="#integer_lattice_with_isometry-Tuple{ZZLat, QQMatrix}"><code>integer_lattice_with_isometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integer_lattice_with_isometry(L::ZZLat, f::QQMatrix; check::Bool = true,
                                            ambient_representation = true)
                                                         -&gt; ZZLatWithIsom</code></pre><p>Given a <span>$\mathbb Z$</span>-lattice <span>$L$</span> and a matrix <span>$f$</span>, if <span>$f$</span> defines an isometry of <span>$L$</span> of order <span>$n$</span>, return the corresponding lattice with isometry pair <span>$(L, f)$</span>.</p><p>If <code>ambient_representation</code> is set to <code>true</code>, <span>$f$</span> is consider as an isometry of the ambient space of <span>$L$</span> and the induced isometry on <span>$L$</span> is automatically computed as long as <span>$f$</span> preserves <span>$L$</span>.</p><p>Otherwise, an isometry of the ambient space of <span>$L$</span> is constructed, setting the identity on the complement of the rational span of <span>$L$</span> if it is not of full rank.</p><p><strong>Examples</strong></p><p>The way we construct the lattice can have an influence on the isometry of the ambient space we store. Indeed, if one mentions an isometry of the lattice, this isometry will be extended by the identity on the orthogonal complement of the rational span of the lattice. In the following example, <code>Lf</code> and <code>Lf2</code> are the same object, but the isometry of their ambient space stored are different (one has order 2, the other one is the identity).</p><pre><code class="language-julia-repl hljs">julia&gt; B = matrix(QQ, 3, 5, [1 0 0 0 0;
                             0 0 1 0 1;
                             0 0 0 1 0]);

julia&gt; G = matrix(QQ, 5, 5, [ 2 -1  0  0  0;
                             -1  2 -1  0  0;
                              0 -1  2 -1  0;
                              0  0 -1  2 -1;
                              0  0  0 -1  2]);

julia&gt; L = integer_lattice(B; gram = G);

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f)
Integer lattice of rank 3 and degree 5
  with isometry of finite order 1
  given by
  [1   0   0]
  [0   1   0]
  [0   0   1]

julia&gt; ambient_isometry(Lf)
[ 1    0    0    0    0]
[-1   -1   -1   -1   -1]
[ 0    0    0    0    1]
[ 0    0    0    1    0]
[ 0    0    1    0    0]

julia&gt; Lf2 = integer_lattice_with_isometry(L, isometry(Lf); ambient_representation=false)
Integer lattice of rank 3 and degree 5
  with isometry of finite order 1
  given by
  [1   0   0]
  [0   1   0]
  [0   0   1]

julia&gt; ambient_isometry(Lf2)
[1   0   0   0   0]
[0   1   0   0   0]
[0   0   1   0   0]
[0   0   0   1   0]
[0   0   0   0   1]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="integer_lattice_with_isometry-Tuple{ZZLat}" href="#integer_lattice_with_isometry-Tuple{ZZLat}"><code>integer_lattice_with_isometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integer_lattice_with_isometry(L::ZZLat; neg::Bool = false) -&gt; ZZLatWithIsom</code></pre><p>Given a <span>$\mathbb Z$</span>-lattice <span>$L$</span> return the lattice with isometry pair <span>$(L, f)$</span>, where <span>$f$</span> corresponds to the identity mapping of <span>$L$</span>.</p><p>If <code>neg</code> is set to <code>true</code>, then the isometry <span>$f$</span> is negative the identity of <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L; neg=true)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 2
  given by
  [-1    0    0    0    0]
  [ 0   -1    0    0    0]
  [ 0    0   -1    0    0]
  [ 0    0    0   -1    0]
  [ 0    0    0    0   -1]</code></pre></div></section></article><p>By default, the first constructor will always check whether the matrix defines an isometry of the lattice, or its ambient space. We recommend not to disable this parameter to avoid any further issues. Note that as in the case of quadratic spaces with isometry, both isometries of integer lattices of <em>finite order</em> and <em>infinite order</em> are supported.</p><p>Another way of constructing such lattices with isometry is by fixing an ambient quadratic space with isometry, of type <code>QuadSpaceWithIsom</code>, and specifying a basis for an integral lattice in that space. If this lattice is preserved by the fixed isometry of the quadratic space considered, then we endow it with the induced action.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="lattice-Tuple{QuadSpaceWithIsom}" href="#lattice-Tuple{QuadSpaceWithIsom}"><code>lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice(Vf::QuadSpaceWithIsom) -&gt; ZZLatWithIsom</code></pre><p>Given a quadratic space with isometry <span>$(V, f)$</span>, return the full rank lattice <span>$L$</span> in <span>$V$</span> with basis the standard basis, together with the induced action of <span>$f$</span> on <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; V = quadratic_space(QQ, QQ[2 -1; -1 2])
Quadratic space of dimension 2
  over rational field
with gram matrix
[ 2   -1]
[-1    2]

julia&gt; f = matrix(QQ, 2, 2, [1 1; 0 -1])
[1    1]
[0   -1]

julia&gt; Vf = quadratic_space_with_isometry(V, f)
Quadratic space of dimension 2
  with isometry of finite order 2
  given by
  [1    1]
  [0   -1]

julia&gt; Lf = lattice(Vf)
Integer lattice of rank 2 and degree 2
  with isometry of finite order 2
  given by
  [1    1]
  [0   -1]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="lattice-Tuple{QuadSpaceWithIsom, MatElem{&lt;:Union{Integer, QQFieldElem, ZZRingElem, Rational}}}" href="#lattice-Tuple{QuadSpaceWithIsom, MatElem{&lt;:Union{Integer, QQFieldElem, ZZRingElem, Rational}}}"><code>lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice(Vf::QuadSpaceWithIsom, B::MatElem{&lt;:RationalUnion};
                               isbasis::Bool = true, check::Bool = true)
                                                          -&gt; ZZLatWithIsom</code></pre><p>Given a quadratic space with isometry <span>$(V, f)$</span> and a matrix <span>$B$</span> generating a lattice <span>$L$</span> in <span>$V$</span>, if <span>$L$</span> is preserved under the action of <span>$f$</span>, return the lattice with isometry <span>$(L, f_L)$</span> where <span>$f_L$</span> is induced by the action of <span>$f$</span> on <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; V = quadratic_space(QQ, QQ[ 2 -1  0  0  0;
                                  -1  2 -1  0  0;
                                   0 -1  2 -1  0;
                                   0  0 -1  2 -1;
                                   0  0  0 -1  2]);

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; Vf = quadratic_space_with_isometry(V, f);

julia&gt; B = matrix(QQ,3,5,[1 0 0 0 0;
                          0 0 1 0 1;
                          0 0 0 1 0])
[1   0   0   0   0]
[0   0   1   0   1]
[0   0   0   1   0]

julia&gt; lattice(Vf, B)
Integer lattice of rank 3 and degree 5
  with isometry of finite order 1
  given by
  [1   0   0]
  [0   1   0]
  [0   0   1]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="lattice_in_same_ambient_space-Tuple{ZZLatWithIsom, MatElem}" href="#lattice_in_same_ambient_space-Tuple{ZZLatWithIsom, MatElem}"><code>lattice_in_same_ambient_space</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice_in_same_ambient_space(L::ZZLatWithIsom, B::MatElem;
                                                check::Bool = true)
                                                        -&gt; ZZLatWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> and a matrix <span>$B$</span> whose rows define a free system of vectors in the ambient space <span>$V$</span> of <span>$L$</span>, if the lattice <span>$M$</span> in <span>$V$</span> defined by <span>$B$</span> is preserved under the fixed isometry <span>$g$</span> of <span>$V$</span> inducing <span>$f$</span> on <span>$L$</span>, return the lattice with isometry pair <span>$(M, f_M)$</span> where <span>$f_M$</span> is induced by the action of <span>$g$</span> on <span>$M$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; B = matrix(QQ,3,5,[1 0 0 0 0;
                          0 0 1 0 1;
                          0 0 0 1 0])
[1   0   0   0   0]
[0   0   1   0   1]
[0   0   0   1   0]

julia&gt; I = lattice_in_same_ambient_space(Lf, B)
Integer lattice of rank 3 and degree 5
  with isometry of finite order 1
  given by
  [1   0   0]
  [0   1   0]
  [0   0   1]

julia&gt; ambient_space(I) === ambient_space(Lf)
true</code></pre></div></section></article><h2 id="Attributes-and-first-operations"><a class="docs-heading-anchor" href="#Attributes-and-first-operations">Attributes and first operations</a><a id="Attributes-and-first-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Attributes-and-first-operations" title="Permalink"></a></h2><p>Given a lattice with isometry <span>$Lf := (L, f)$</span>, one can have access most of the attributes of <span>$L$</span> and <span>$f$</span> by calling the similar function for the pair. For instance, in order to know the genus of <span>$L$</span>, one can simply call <code>genus(Lf)</code>. Here is a list of what are the current accessible attributes:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="basis_matrix-Tuple{ZZLatWithIsom}" href="#basis_matrix-Tuple{ZZLatWithIsom}"><code>basis_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis_matrix(Lf::ZZLatWithIsom) -&gt; QQMatrix</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the basis matrix of the underlying lattice <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ,5,5,[ 1  0  0  0  0;
                          -1 -1 -1 -1 -1;
                           0  0  0  0  1;
                           0  0  0  1  0;
                           0  0  1  0  0])
[ 1    0    0    0    0]
[-1   -1   -1   -1   -1]
[ 0    0    0    0    1]
[ 0    0    0    1    0]
[ 0    0    1    0    0]

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; invariant_lattice(Lf);

julia&gt; I = invariant_lattice(Lf);

julia&gt; basis_matrix(I)
[1   0   0   0   0]
[0   0   1   0   1]
[0   0   0   1   0]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="characteristic_polynomial-Tuple{ZZLatWithIsom}" href="#characteristic_polynomial-Tuple{ZZLatWithIsom}"><code>characteristic_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">characteristic_polynomial(Lf::ZZLatWithIsom) -&gt; QQPolyRingElem</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the characteristic polynomial of the underlying isometry <span>$f$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L; neg=true);

julia&gt; factor(characteristic_polynomial(Lf))
1 * (x + 1)^5</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="degree-Tuple{ZZLatWithIsom}" href="#degree-Tuple{ZZLatWithIsom}"><code>degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degree(Lf::ZZLatWithIsom) -&gt; Int</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the degree of the underlying lattice <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; degree(Lf)
5</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="det-Tuple{ZZLatWithIsom}" href="#det-Tuple{ZZLatWithIsom}"><code>det</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">det(Lf::ZZLatWithIsom) -&gt; QQFieldElem</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the determinant of the underlying lattice <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; det(Lf)
6</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="discriminant-Tuple{ZZLatWithIsom}" href="#discriminant-Tuple{ZZLatWithIsom}"><code>discriminant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discriminant(Lf::ZZLatWithIsom) -&gt; QQFieldElem</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the discriminant of the underlying lattice <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; discriminant(Lf) == det(Lf) == 6
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="genus-Tuple{ZZLatWithIsom}" href="#genus-Tuple{ZZLatWithIsom}"><code>genus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genus(Lf::ZZLatWithIsom) -&gt; ZZGenus</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the genus of the underlying  lattice <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L; neg=true);

julia&gt; genus(Lf)
Genus symbol for integer lattices
Signatures: (5, 0, 0)
Local symbols:
  Local genus symbol at 2: 1^-4 2^1_7
  Local genus symbol at 3: 1^-4 3^1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="gram_matrix-Tuple{ZZLatWithIsom}" href="#gram_matrix-Tuple{ZZLatWithIsom}"><code>gram_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gram_matrix(Lf::ZZLatWithIsom) -&gt; QQMatrix</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the gram matrix of the underlying lattice <span>$L$</span> with respect to its basis matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; gram_matrix(Lf)
[ 2   -1    0    0    0]
[-1    2   -1    0    0]
[ 0   -1    2   -1    0]
[ 0    0   -1    2   -1]
[ 0    0    0   -1    2]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_definite-Tuple{ZZLatWithIsom}" href="#is_definite-Tuple{ZZLatWithIsom}"><code>is_definite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_definite(Lf::ZZLatWithIsom) -&gt; Bool</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return whether the underlying lattice <span>$L$</span> is definite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; is_definite(Lf)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_even-Tuple{ZZLatWithIsom}" href="#is_even-Tuple{ZZLatWithIsom}"><code>is_even</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_even(Lf::ZZLatWithIsom) -&gt; Bool</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return whether the underlying lattice <span>$L$</span> is even.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; is_even(Lf)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_elementary-Tuple{ZZLatWithIsom, Union{Integer, ZZRingElem}}" href="#is_elementary-Tuple{ZZLatWithIsom, Union{Integer, ZZRingElem}}"><code>is_elementary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_elementary(Lf::ZZLatWithIsom, p::IntegerUnion) -&gt; Bool</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> and a prime number <span>$p$</span>, return whether <span>$L$</span> is <span>$p$</span>-elementary, that is whether its discriminant group is an elementary <span>$p$</span>-group.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:E, 7);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; is_elementary(Lf, 3)
false

julia&gt; is_elementary(Lf, 2)
true

julia&gt; genus(Lf)
Genus symbol for integer lattices
Signatures: (7, 0, 0)
Local symbol:
  Local genus symbol at 2: 1^6 2^1_7</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_elementary_with_prime-Tuple{ZZLatWithIsom}" href="#is_elementary_with_prime-Tuple{ZZLatWithIsom}"><code>is_elementary_with_prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_elementary_with_prime(Lf::ZZLatWithIsom) -&gt; Bool, ZZRingElem</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return whether <span>$L$</span> is elementary, that is whether <span>$L$</span> is integral and its discriminant group is an elemenentary <span>$p$</span>-group for some prime number <span>$p$</span>. In case it is, <span>$p$</span> is also returned as second output.</p><p>Note that for unimodular lattices, this function returns <code>(true, 1)</code>. If the lattice is not elementary, the second return value is <code>-1</code> by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A, 7);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; is_elementary_with_prime(Lf)
(false, -1)

julia&gt; is_primary(Lf, 2)
true

julia&gt; genus(Lf)
Genus symbol for integer lattices
Signatures: (7, 0, 0)
Local symbol:
  Local genus symbol at 2: 1^6 8^1_7</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_integral-Tuple{ZZLatWithIsom}" href="#is_integral-Tuple{ZZLatWithIsom}"><code>is_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_integral(Lf::ZZLatWithIsom) -&gt; Bool</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return whether the underlying lattice <span>$L$</span> is integral.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; is_integral(Lf)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_positive_definite-Tuple{ZZLatWithIsom}" href="#is_positive_definite-Tuple{ZZLatWithIsom}"><code>is_positive_definite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_positive_definite(Lf::ZZLatWithIsom) -&gt; Bool</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return whether the underlying lattice <span>$L$</span> is positive definite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; is_positive_definite(Lf)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_primary-Tuple{ZZLatWithIsom, Union{Integer, ZZRingElem}}" href="#is_primary-Tuple{ZZLatWithIsom, Union{Integer, ZZRingElem}}"><code>is_primary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_primary(Lf::ZZLatWithIsom, p::IntegerUnion) -&gt; Bool</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> and a prime number <span>$p$</span>, return whether <span>$L$</span> is <span>$p$</span>-primary, that is whether its discriminant group is a <span>$p$</span>-group.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A, 6);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; is_primary(Lf, 7)
true

julia&gt; genus(Lf)
Genus symbol for integer lattices
Signatures: (6, 0, 0)
Local symbols:
  Local genus symbol at 2: 1^6
  Local genus symbol at 7: 1^-5 7^-1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_primary_with_prime-Tuple{ZZLatWithIsom}" href="#is_primary_with_prime-Tuple{ZZLatWithIsom}"><code>is_primary_with_prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_primary_with_prime(Lf::ZZLatWithIsom) -&gt; Bool, ZZRingElem</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return whether <span>$L$</span> is primary, that is whether <span>$L$</span> is integral and its discriminant group is a <span>$p$</span>-group for some prime number <span>$p$</span>. In case it is, <span>$p$</span> is also returned as second output.</p><p>Note that for unimodular lattices, this function returns <code>(true, 1)</code>. If the lattice is not primary, the second return value is <code>-1</code> by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A, 5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; is_primary_with_prime(Lf)
(false, -1)

julia&gt; genus(Lf)
Genus symbol for integer lattices
Signatures: (5, 0, 0)
Local symbols:
  Local genus symbol at 2: 1^-4 2^1_7
  Local genus symbol at 3: 1^-4 3^1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_negative_definite-Tuple{ZZLatWithIsom}" href="#is_negative_definite-Tuple{ZZLatWithIsom}"><code>is_negative_definite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_negative_definite(Lf::ZZLatWithIsom) -&gt; Bool</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return whether the underlying lattice <span>$L$</span> is negative definite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; is_negative_definite(Lf)
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_unimodular-Tuple{ZZLatWithIsom}" href="#is_unimodular-Tuple{ZZLatWithIsom}"><code>is_unimodular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_unimodular(Lf::ZZLatWithIsom) -&gt; Bool</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return whether `<span>$L$</span> is unimodular, that is whether its discriminant group is trivial.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:E, 8);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; is_unimodular(Lf)
true

julia&gt; genus(Lf)
Genus symbol for integer lattices
Signatures: (8, 0, 0)
Local symbol:
  Local genus symbol at 2: 1^8</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="minimum-Tuple{ZZLatWithIsom}" href="#minimum-Tuple{ZZLatWithIsom}"><code>minimum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum(Lf::ZZLatWithIsom) -&gt; QQFieldElem</code></pre><p>Given a positive definite lattice with isometry <span>$(L, f)$</span>, return the minimum of the underlying lattice <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; minimum(Lf)
2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="minimal_polynomial-Tuple{ZZLatWithIsom}" href="#minimal_polynomial-Tuple{ZZLatWithIsom}"><code>minimal_polynomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimal_polynomial(Lf::ZZLatWithIsom) -&gt; QQPolyRingElem</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the minimal polynomial of the underlying isometry <span>$f$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L; neg=true);

julia&gt; minimal_polynomial(Lf)
x + 1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="norm-Tuple{ZZLatWithIsom}" href="#norm-Tuple{ZZLatWithIsom}"><code>norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(Lf::ZZLatWithIsom) -&gt; QQFieldElem</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the norm of the underlying lattice <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; norm(Lf)
2</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="rank-Tuple{ZZLatWithIsom}" href="#rank-Tuple{ZZLatWithIsom}"><code>rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rank(Lf::ZZLatWithIsom) -&gt; Integer</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the rank of the underlying lattice <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L; neg=true);

julia&gt; rank(Lf)
5</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="rational_span-Tuple{ZZLatWithIsom}" href="#rational_span-Tuple{ZZLatWithIsom}"><code>rational_span</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rational_span(Lf::ZZLatWithIsom) -&gt; QuadSpaceWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the rational span <span>$L \otimes \mathbb{Q}$</span> of the underlying lattice <span>$L$</span> together with the underlying isometry of <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; Vf = rational_span(Lf)
Quadratic space of dimension 5
  with isometry of finite order 1
  given by
  [1   0   0   0   0]
  [0   1   0   0   0]
  [0   0   1   0   0]
  [0   0   0   1   0]
  [0   0   0   0   1]

julia&gt; typeof(Vf)
QuadSpaceWithIsom</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="scale-Tuple{ZZLatWithIsom}" href="#scale-Tuple{ZZLatWithIsom}"><code>scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale(Lf::ZZLatWithIsom) -&gt; QQFieldElem</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the scale of the underlying lattice <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; scale(Lf)
1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="signature_tuple-Tuple{ZZLatWithIsom}" href="#signature_tuple-Tuple{ZZLatWithIsom}"><code>signature_tuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signature_tuple(Lf::ZZLatWithIsom) -&gt; Tuple{Int, Int, Int}</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the signature tuple of the underlying lattice <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; Lf = integer_lattice_with_isometry(L);

julia&gt; signature_tuple(Lf)
(5, 0, 0)</code></pre></div></section></article><p>Similarly, some basic operations on <span>$\mathbb Z$</span>-lattices and matrices are available for integer lattices with isometry.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="^-Tuple{ZZLatWithIsom, Int64}" href="#^-Tuple{ZZLatWithIsom, Int64}"><code>^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(Lf::ZZLatWithIsom, n::Int) -&gt; ZZLatWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> and an integer <span>$n$</span>, return the pair <span>$(L, f^n)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 2
  given by
  [ 1    0    0    0    0]
  [-1   -1   -1   -1   -1]
  [ 0    0    0    0    1]
  [ 0    0    0    1    0]
  [ 0    0    1    0    0]

julia&gt; Lf^0
Integer lattice of rank 5 and degree 5
  with isometry of finite order 1
  given by
  [1   0   0   0   0]
  [0   1   0   0   0]
  [0   0   1   0   0]
  [0   0   0   1   0]
  [0   0   0   0   1]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="biproduct-Tuple{Vector{ZZLatWithIsom}}" href="#biproduct-Tuple{Vector{ZZLatWithIsom}}"><code>biproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">biproduct(x::Vector{ZZLatWithIsom}) -&gt; ZZLatWithIsom,
                                                  Vector{AbstractSpaceMor},
                                                  Vector{AbstractSpaceMor}
biproduct(x::Vararg{ZZLatWithIsom}) -&gt; ZZLatWithIsom,
                                                  Vector{AbstractSpaceMor},
                                                  Vector{AbstractSpaceMor}</code></pre><p>Given a collection of lattices with isometries <span>$(L_1, f_1), \ldots, (L_n, f_n)$</span>, return the lattice with isometry <span>$(L, f)$</span> together with the injections <span>$L_i \to L$</span> and the projections <span>$L \to L_i$</span>, where <span>$L$</span> is the biproduct <span>$L := L_1 \oplus \ldots \oplus L_n$</span> and <span>$f$</span> is the isometry of <span>$L$</span> induced by the diagonal actions of the <span>$f_i$</span>&#39;s.</p><p>For objects of type <code>ZZLatWithIsom</code>, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain <span>$(L, f)$</span> as a direct sum with the injections <span>$L_i \to L$</span>, one should call <code>direct_sum(x)</code>. If one wants to obtain <span>$(L, f)$</span> as a direct product with the projections <span>$L \to L_i$</span>, one should call <code>direct_product(x)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; g = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 2
  given by
  [ 1    0    0    0    0]
  [-1   -1   -1   -1   -1]
  [ 0    0    0    0    1]
  [ 0    0    0    1    0]
  [ 0    0    1    0    0]

julia&gt; Lg = integer_lattice_with_isometry(L, g)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 5
  given by
  [1    1    1    1    1]
  [0   -1   -1   -1   -1]
  [0    1    0    0    0]
  [0    0    1    0    0]
  [0    0    0    1    0]

julia&gt; Lh, inj, proj = biproduct(Lf, Lg)
(Integer lattice with isometry of finite order 10, AbstractSpaceMor[Map: quadratic space -&gt; quadratic space, Map: quadratic space -&gt; quadratic space], AbstractSpaceMor[Map: quadratic space -&gt; quadratic space, Map: quadratic space -&gt; quadratic space])

julia&gt; Lh
Integer lattice of rank 10 and degree 10
  with isometry of finite order 10
  given by
  [ 1    0    0    0    0   0    0    0    0    0]
  [-1   -1   -1   -1   -1   0    0    0    0    0]
  [ 0    0    0    0    1   0    0    0    0    0]
  [ 0    0    0    1    0   0    0    0    0    0]
  [ 0    0    1    0    0   0    0    0    0    0]
  [ 0    0    0    0    0   1    1    1    1    1]
  [ 0    0    0    0    0   0   -1   -1   -1   -1]
  [ 0    0    0    0    0   0    1    0    0    0]
  [ 0    0    0    0    0   0    0    1    0    0]
  [ 0    0    0    0    0   0    0    0    1    0]

julia&gt; matrix(compose(inj[1], proj[1]))
[1   0   0   0   0]
[0   1   0   0   0]
[0   0   1   0   0]
[0   0   0   1   0]
[0   0   0   0   1]

julia&gt; matrix(compose(inj[1], proj[2]))
[0   0   0   0   0]
[0   0   0   0   0]
[0   0   0   0   0]
[0   0   0   0   0]
[0   0   0   0   0]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="direct_product-Tuple{Vector{ZZLatWithIsom}}" href="#direct_product-Tuple{Vector{ZZLatWithIsom}}"><code>direct_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">direct_product(x::Vector{ZZLatWithIsom}) -&gt; ZZLatWithIsom,
                                                   Vector{AbstractSpaceMor}
direct_product(x::Vararg{ZZLatWithIsom}) -&gt; ZZLatWithIsom,
                                                   Vector{AbstractSpaceMor}</code></pre><p>Given a collection of lattices with isometries <span>$(L_1, f_1), \ldots, (L_n, f_n)$</span>, return the lattice with isometry <span>$(L, f)$</span> together with the projections <span>$L \to L_i$</span>, where <span>$L$</span> is the direct product <span>$L := L_1 \times \ldots \times L_n$</span> and <span>$f$</span> is the isometry of <span>$L$</span> induced by the diagonal actions of the <span>$f_i$</span>&#39;s.</p><p>For objects of type <code>ZZLatWithIsom</code>, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain <span>$(L, f)$</span> as a direct sum with the injections <span>$L_i \to L$</span>, one should call <code>direct_sum(x)</code>. If one wants to obtain <span>$(L, f)$</span> as a biproduct with the injections <span>$L_i \to L$</span> and the projections <span>$L \to L_i$</span>, one should call <code>biproduct(x)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; g = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 2
  given by
  [ 1    0    0    0    0]
  [-1   -1   -1   -1   -1]
  [ 0    0    0    0    1]
  [ 0    0    0    1    0]
  [ 0    0    1    0    0]

julia&gt; Lg = integer_lattice_with_isometry(L, g)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 5
  given by
  [1    1    1    1    1]
  [0   -1   -1   -1   -1]
  [0    1    0    0    0]
  [0    0    1    0    0]
  [0    0    0    1    0]

julia&gt; Lh, proj = direct_product(Lf, Lg)
(Integer lattice with isometry of finite order 10, AbstractSpaceMor[Map: quadratic space -&gt; quadratic space, Map: quadratic space -&gt; quadratic space])

julia&gt; Lh
Integer lattice of rank 10 and degree 10
  with isometry of finite order 10
  given by
  [ 1    0    0    0    0   0    0    0    0    0]
  [-1   -1   -1   -1   -1   0    0    0    0    0]
  [ 0    0    0    0    1   0    0    0    0    0]
  [ 0    0    0    1    0   0    0    0    0    0]
  [ 0    0    1    0    0   0    0    0    0    0]
  [ 0    0    0    0    0   1    1    1    1    1]
  [ 0    0    0    0    0   0   -1   -1   -1   -1]
  [ 0    0    0    0    0   0    1    0    0    0]
  [ 0    0    0    0    0   0    0    1    0    0]
  [ 0    0    0    0    0   0    0    0    1    0]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="direct_sum-Tuple{Vector{ZZLatWithIsom}}" href="#direct_sum-Tuple{Vector{ZZLatWithIsom}}"><code>direct_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">direct_sum(x::Vector{ZZLatWithIsom}) -&gt; ZZLatWithIsom,
                                                   Vector{AbstractSpaceMor}
direct_sum(x::Vararg{ZZLatWithIsom}) -&gt; ZZLatWithIsom,
                                                   Vector{AbstractSpaceMor}</code></pre><p>Given a collection of lattices with isometries <span>$(L_1, f_1), \ldots, (L_n, f_n)$</span>, return the lattice with isometry <span>$(L, f)$</span> together with the injections <span>$L_i \to L$</span>, where <span>$L$</span> is the direct sum <span>$L := L_1 \oplus \ldots \oplus L_n$</span> and <span>$f$</span> is the isometry of <span>$L$</span> induced by the diagonal actions of the <span>$f_i$</span>&#39;s.</p><p>For objects of type <code>ZZLatWithIsom</code>, finite direct sums and finite direct products agree and they are therefore called biproducts. If one wants to obtain <span>$(L, f)$</span> as a direct product with the projections <span>$L \to L_i$</span>, one should call <code>direct_product(x)</code>. If one wants to obtain <span>$(L, f)$</span> as a biproduct with the injections <span>$L_i \to L$</span> and the projections <span>$L \to L_i$</span>, one should call <code>biproduct(x)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; g = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 2
  given by
  [ 1    0    0    0    0]
  [-1   -1   -1   -1   -1]
  [ 0    0    0    0    1]
  [ 0    0    0    1    0]
  [ 0    0    1    0    0]

julia&gt; Lg = integer_lattice_with_isometry(L, g)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 5
  given by
  [1    1    1    1    1]
  [0   -1   -1   -1   -1]
  [0    1    0    0    0]
  [0    0    1    0    0]
  [0    0    0    1    0]

julia&gt; Lh, inj = direct_sum(Lf, Lg)
(Integer lattice with isometry of finite order 10, AbstractSpaceMor[Map: quadratic space -&gt; quadratic space, Map: quadratic space -&gt; quadratic space])

julia&gt; Lh
Integer lattice of rank 10 and degree 10
  with isometry of finite order 10
  given by
  [ 1    0    0    0    0   0    0    0    0    0]
  [-1   -1   -1   -1   -1   0    0    0    0    0]
  [ 0    0    0    0    1   0    0    0    0    0]
  [ 0    0    0    1    0   0    0    0    0    0]
  [ 0    0    1    0    0   0    0    0    0    0]
  [ 0    0    0    0    0   1    1    1    1    1]
  [ 0    0    0    0    0   0   -1   -1   -1   -1]
  [ 0    0    0    0    0   0    1    0    0    0]
  [ 0    0    0    0    0   0    0    1    0    0]
  [ 0    0    0    0    0   0    0    0    1    0]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="dual-Tuple{ZZLatWithIsom}" href="#dual-Tuple{ZZLatWithIsom}"><code>dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual(Lf::ZZLatWithIsom) -&gt; ZZLatWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> inside the space <span>$(V, \Phi)$</span>, such that <span>$f$</span> is induced by an isometry <span>$g$</span> of <span>$(V, \Phi)$</span>, return the lattice with isometry <span>$(L^{\vee}, h)$</span> where <span>$L^{\vee}$</span> is the dual of <span>$L$</span> in <span>$(V, \Phi)$</span> and <span>$h$</span> is induced by <span>$g$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 2
  given by
  [ 1    0    0    0    0]
  [-1   -1   -1   -1   -1]
  [ 0    0    0    0    1]
  [ 0    0    0    1    0]
  [ 0    0    1    0    0]

julia&gt; Lfv = dual(Lf)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 2
  given by
  [1   -1   0   0   0]
  [0   -1   0   0   0]
  [0   -1   0   0   1]
  [0   -1   0   1   0]
  [0   -1   1   0   0]

julia&gt; ambient_space(Lfv) == ambient_space(Lf)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="lll-Tuple{ZZLatWithIsom}" href="#lll-Tuple{ZZLatWithIsom}"><code>lll</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lll(Lf::ZZLatWithIsom) -&gt; ZZLatWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the same lattice with isometry with a different basis matrix for <span>$L$</span>  obtained by performing an LLL-reduction on the associated gram matrix of <span>$L$</span>.</p><p>Note that matrix representing the action of <span>$f$</span> on <span>$L$</span> changes but the global action on the ambient space of <span>$L$</span> stays the same.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 2
  given by
  [ 1    0    0    0    0]
  [-1   -1   -1   -1   -1]
  [ 0    0    0    0    1]
  [ 0    0    0    1    0]
  [ 0    0    1    0    0]

julia&gt; Lf2 = lll(Lf)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 2
  given by
  [ 1    0    0    0    0]
  [-1    0    0    0   -1]
  [-1    0    0   -1    0]
  [-1    0   -1    0    0]
  [-1   -1    0    0    0]

julia&gt; ambient_space(Lf2) == ambient_space(Lf)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="orthogonal_submodule-Tuple{ZZLatWithIsom, QQMatrix}" href="#orthogonal_submodule-Tuple{ZZLatWithIsom, QQMatrix}"><code>orthogonal_submodule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orthogonal_submodule(Lf::ZZLatWithIsom, B::QQMatrix) -&gt; ZZLatWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> and a matrix <span>$B$</span> with rational entries defining an <span>$f$</span>-stable sublattice of <span>$L$</span>, return the largest submodule of <span>$L$</span> orthogonal to each row of <span>$B$</span>, equipped with the induced action from <span>$f$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; B = matrix(QQ,3,5,[1 0 0 0 0;
                          0 0 1 0 1;
                          0 0 0 1 0])
[1   0   0   0   0]
[0   0   1   0   1]
[0   0   0   1   0]

julia&gt; orthogonal_submodule(Lf, B)
Integer lattice of rank 2 and degree 5
  with isometry of finite order 2
  given by
  [-1    0]
  [ 0   -1]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="rescale-Tuple{ZZLatWithIsom, Union{Integer, QQFieldElem, ZZRingElem, Rational}}" href="#rescale-Tuple{ZZLatWithIsom, Union{Integer, QQFieldElem, ZZRingElem, Rational}}"><code>rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(Lf::ZZLatWithIsom, a::RationalUnion) -&gt; ZZLatWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> and a rational number <span>$a$</span>, return the lattice with isometry <span>$(L(a), f)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5)
Integer lattice of rank 5 and degree 5
with gram matrix
[ 2   -1    0    0    0]
[-1    2   -1    0    0]
[ 0   -1    2   -1    0]
[ 0    0   -1    2   -1]
[ 0    0    0   -1    2]

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 2
  given by
  [ 1    0    0    0    0]
  [-1   -1   -1   -1   -1]
  [ 0    0    0    0    1]
  [ 0    0    0    1    0]
  [ 0    0    1    0    0]

julia&gt; Lf2 = rescale(Lf, 1//2)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 2
  given by
  [ 1    0    0    0    0]
  [-1   -1   -1   -1   -1]
  [ 0    0    0    0    1]
  [ 0    0    0    1    0]
  [ 0    0    1    0    0]

julia&gt; lattice(Lf2)
Integer lattice of rank 5 and degree 5
with gram matrix
[    1   -1//2       0       0       0]
[-1//2       1   -1//2       0       0]
[    0   -1//2       1   -1//2       0]
[    0       0   -1//2       1   -1//2]
[    0       0       0   -1//2       1]</code></pre></div></section></article><h2 id="Type-for-finite-order-isometries"><a class="docs-heading-anchor" href="#Type-for-finite-order-isometries">Type for finite order isometries</a><a id="Type-for-finite-order-isometries-1"></a><a class="docs-heading-anchor-permalink" href="#Type-for-finite-order-isometries" title="Permalink"></a></h2><p>Given a lattice with isometry <span>$Lf := (L, f)$</span> where <span>$f$</span> is of finite order <span>$n$</span>, one can compute the <em>type</em> of <span>$Lf$</span>, which can be seen as an equivalent of the <em>genus</em> used to classified single lattices.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="type-Tuple{ZZLatWithIsom}" href="#type-Tuple{ZZLatWithIsom}"><code>type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">type(Lf::ZZLatWithIsom)
                  -&gt; Dict{Int, Tuple{ &lt;: Union{ZZGenus, HermGenus}, ZZGenus}}</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> with <span>$f$</span> of finite order <span>$n$</span>, return the type of the pair <span>$(L, f)$</span>.</p><p>In this context, the type is defined as follows: for each divisor <span>$k$</span> of <span>$n$</span>, the <span>$k$</span>-type of <span>$(L, f)$</span> is the tuple <span>$(H_k, A_K)$</span> consisting of the genus <span>$H_k$</span> of the lattice <span>$\ker(\Phi_k(f))$</span> viewed as a hermitian <span>$\mathbb{Z}[\zeta_k]$</span>- lattice (so a <span>$\mathbb{Z}$</span>-lattice for <span>$k= 1, 2$</span>) and of the genus <span>$A_k$</span> of the <span>$\mathbb{Z}$</span>-lattice <span>$\ker(f^k-1)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; t = type(Lf);

julia&gt; genus(invariant_lattice(Lf)) == t[1][1]
true</code></pre></div></section></article><p>Since determining whether two pairs of lattices with isometry are isomorphic is a challenging task, one can perform a coarser comparison by looking at the type. This set of data keeps track of some local and global invariants of the pair <span>$(L, f)$</span> with respect to the action of <span>$f$</span> on <span>$L$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_of_type-Tuple{ZZLatWithIsom, Dict}" href="#is_of_type-Tuple{ZZLatWithIsom, Dict}"><code>is_of_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_of_type(Lf::ZZLatWithIsom, t::Dict) -&gt; Bool</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return whether <span>$(L, f)$</span> is of type <span>$t$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; t = type(Lf);

julia&gt; is_of_type(Lf, t)
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_of_same_type-Tuple{ZZLatWithIsom, ZZLatWithIsom}" href="#is_of_same_type-Tuple{ZZLatWithIsom, ZZLatWithIsom}"><code>is_of_same_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_of_same_type(Lf::ZZLatWithIsom, Mg::ZZLatWithIsom) -&gt; Bool</code></pre><p>Given two lattices with isometry <span>$(L, f)$</span> and <span>$(M, g)$</span>, return whether they are of the same type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; M = coinvariant_lattice(Lf);

julia&gt; is_of_same_type(Lf, M)
false</code></pre></div></section></article><p>Finally, if the minimal polynomial of <span>$f$</span> is irreducible, then we say that the pair <span>$(L, f)$</span> is of <em>hermitian type</em>. The type of a lattice with isometry of hermitian type is called <em>hermitian</em> (note that the type is only defined for finite order isometries).</p><p>These names follow from the fact that, by the trace equivalence, one can associate to the pair <span>$(L, f)$</span> a hermitian lattice over the equation order of <span>$f$</span>, if it is maximal in the associated number field <span>$\mathbb{Q}[f]$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_of_hermitian_type-Tuple{ZZLatWithIsom}" href="#is_of_hermitian_type-Tuple{ZZLatWithIsom}"><code>is_of_hermitian_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_of_hermitian_type(Lf::ZZLatWithIsom) -&gt; Bool</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return whether the minimal polynomial of the underlying isometry <span>$f$</span> is irreducible.</p><p>Note that if <span>$(L, f)$</span> is of hermitian type with <span>$f$</span> of minimal polynomial <span>$\chi$</span>, then <span>$L$</span> can be seen as a hermitian lattice over the order <span>$\mathbb{Z}[\chi]$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f)
Integer lattice of rank 5 and degree 5
  with isometry of finite order 5
  given by
  [1    1    1    1    1]
  [0   -1   -1   -1   -1]
  [0    1    0    0    0]
  [0    0    1    0    0]
  [0    0    0    1    0]

julia&gt; is_of_hermitian_type(Lf)
false

julia&gt; is_of_hermitian_type(coinvariant_lattice(Lf))
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="is_hermitian-Tuple{Dict}" href="#is_hermitian-Tuple{Dict}"><code>is_hermitian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_hermitian(t::Dict) -&gt; Bool</code></pre><p>Given a type <span>$t$</span> of lattices with isometry, return whether <span>$t$</span> is hermitian, i.e. whether it defines the type of a hermitian lattice with isometry.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; M = coinvariant_lattice(Lf);

julia&gt; is_hermitian(type(Lf))
false

julia&gt; is_hermitian(type(M))
true</code></pre></div></section></article><h2 id="Hermitian-structures-and-trace-equivalence"><a class="docs-heading-anchor" href="#Hermitian-structures-and-trace-equivalence">Hermitian structures and trace equivalence</a><a id="Hermitian-structures-and-trace-equivalence-1"></a><a class="docs-heading-anchor-permalink" href="#Hermitian-structures-and-trace-equivalence" title="Permalink"></a></h2><p>As mentioned in the previous section, to a lattice with isometry <span>$Lf := (L, f)$</span> such that the minimal polynomial of <span>$f$</span> is irreducible, one can associate a hermitian lattice <span>$\mathfrak{L}$</span> over the equation order of <span>$f$</span>, if it is maximal, for which <span>$Lf$</span> is the associated trace lattice. Hecke provides the tools to perform the trace equivalence for lattices with isometry of hermitian type.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="hermitian_structure-Tuple{ZZLatWithIsom}" href="#hermitian_structure-Tuple{ZZLatWithIsom}"><code>hermitian_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hermitian_structure(Lf::ZZLatWithIsom) -&gt; HermLat</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> such that the minimal polynomial of the underlying isometry <span>$f$</span> is irreducible, return the hermitian structure of the underlying lattice <span>$L$</span> over the equation order of the minimal polynomial of <span>$f$</span>.</p><p>If it exists, the hermitian structure is stored. For now, we only cover the case where the equation order is maximal (which is always the case when the order is finite, for instance, since the minimal polynomial is cyclotomic).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; M = coinvariant_lattice(Lf)
Integer lattice of rank 4 and degree 5
  with isometry of finite order 5
  given by
  [-1   -1   -1   -1]
  [ 1    0    0    0]
  [ 0    1    0    0]
  [ 0    0    1    0]

julia&gt; H = hermitian_structure(M)
Hermitian lattice of rank 1 and degree 1
  over relative maximal order of Relative number field of degree 2 over maximal real subfield of cyclotomic field of order 5
  with pseudo-basis 
  (1, 1//1 * &lt;1, 1&gt;)
  (z_5, 1//1 * &lt;1, 1&gt;)

julia&gt; res = get_attribute(M, :transfer_data)
Map of change of scalars
  from quadratic space of dimension 4
  to hermitian space of dimension 1

julia&gt; M2, f2 = trace_lattice_with_isometry(H, res)
(Integer lattice of rank 4 and degree 4, [-1 -1 -1 -1; 1 0 0 0; 0 1 0 0; 0 0 1 0])

julia&gt; genus(M) == genus(M2) # One class in this genus, so they are isometric
true

julia&gt; f2 == isometry(M)
true</code></pre></div></section></article><h2 id="Discriminant-groups"><a class="docs-heading-anchor" href="#Discriminant-groups">Discriminant groups</a><a id="Discriminant-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Discriminant-groups" title="Permalink"></a></h2><p>Given an integral lattice with isometry <span>$Lf := (L, f)$</span>, if one denotes by <span>$D_L$</span> the discriminant group of <span>$L$</span>, there exists a natural map <span>$\pi\colon O(L) \to O(D_L)$</span> sending any isometry to its induced action on the discriminant group of <span>$L$</span>. In general, this map is neither injective nor surjective. If we denote by <span>$D_f := \pi(f)$</span> then <span>$\pi$</span> induces a map between centralizers <span>$O(L, f)\to O(D_L, D_f)$</span>. Again, this induced map is in general neither injective nor surjective, and we denote its image by <span>$G_{L,f}$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="discriminant_group-Tuple{ZZLatWithIsom}" href="#discriminant_group-Tuple{ZZLatWithIsom}"><code>discriminant_group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discriminant_group(Lf::ZZLatWithIsom) -&gt; TorQuadModule, AutomorphismGroupElem</code></pre><p>Given an integral lattice with isometry <span>$(L, f)$</span>, return the discriminant group <span>$D_L$</span> of the underlying lattice <span>$L$</span> as well as the image <span>$D_f$</span> of the underlying isometry <span>$f$</span> inside <span>$O(D_L)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; qL, qf = discriminant_group(Lf)
(Finite quadratic module: Z/6 -&gt; Q/2Z, [1])

julia&gt; qL
Finite quadratic module
  over integer ring
Abelian group: Z/6
Bilinear value module: Q/Z
Quadratic value module: Q/2Z
Gram matrix quadratic form: 
[5//6]

julia&gt; qf
Isometry of Finite quadratic module: Z/6 -&gt; Q/2Z defined by 
[1]

julia&gt; f = matrix(QQ, 5, 5, [ 1  0  0  0  0;
                             -1 -1 -1 -1 -1;
                              0  0  0  0  1;
                              0  0  0  1  0;
                              0  0  1  0  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; discriminant_group(Lf)[2]
Isometry of Finite quadratic module: Z/6 -&gt; Q/2Z defined by 
[5]</code></pre></div></section></article><p>For simple cases as for definite lattices, <span>$f$</span> being plus-or-minus the identity or if the rank of <span>$L$</span> is equal to the totient of the order of <span>$f$</span> (in the finite case), <span>$G_{L,f}$</span> can be easily computed. For the remaining cases, we use the hermitian version of <em>Miranda-Morrison theory</em> as presented in [<a href="../../../references/#BH23">BH23</a>]. The general computation of <span>$G_{L, f}$</span> has been implemented in this project and it can be indirectly used through the general following method:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="image_centralizer_in_Oq-Tuple{ZZLatWithIsom}" href="#image_centralizer_in_Oq-Tuple{ZZLatWithIsom}"><code>image_centralizer_in_Oq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">image_centralizer_in_Oq(Lf::ZZLatWithIsom) -&gt; AutomorphismGroup{TorQuadModule},
                                              GAPGroupHomomorphism</code></pre><p>Given an integral lattice with isometry <span>$(L, f)$</span>, return the image <span>$G_L$</span> in <span>$O(D_L, D_f)$</span> of the centralizer <span>$O(L, f)$</span> of <span>$f$</span> in <span>$O(L)$</span>. Here <span>$D_L$</span> denotes the discriminant group of <span>$L$</span> and <span>$D_f$</span> is the isometry of <span>$D_L$</span> induced by <span>$f$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,2);

julia&gt; f = matrix(QQ, 2, 2, [1 1; 0 -1]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; G, _ = image_centralizer_in_Oq(Lf)
(Group of isometries of Finite quadratic module: Z/3 -&gt; Q/2Z generated by 2 elements, Hom: group of isometries of Finite quadratic module generated by 2 elements -&gt; group of isometries of Finite quadratic module generated by 1 elements)

julia&gt; order(G)
2</code></pre></div></section></article><p>For an implementation of the regular Miranda-Morrison theory, we refer to the function <code>image_in_Oq</code> which actually computes the image of <span>$\pi$</span> in both the definite and the indefinite case.</p><p>More generally, for a finitely generated subgroup <span>$G$</span> of <span>$O(L)$</span>, we have implemented a function which computes the representation of <span>$G$</span> on <span>$D_L$</span>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="discriminant_representation-Tuple{ZZLat, MatrixGroup}" href="#discriminant_representation-Tuple{ZZLat, MatrixGroup}"><code>discriminant_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discriminant_representation(L::ZZLat, G::MatrixGroup;
                                      ambient_representation::Bool = true,
                                      check::Bool = true) -&gt; GAPGroupHomomorphism</code></pre><p>Given an integer lattice <span>$L$</span> and a group <span>$G$</span> of isometries of <span>$L$</span>, return the orthogonal representation <span>$G\to O(D_L)$</span> of <span>$G$</span> on the discriminant group <span>$D_L$</span> of <span>$L$</span>.</p><p>If <code>ambient_representation</code> is set to <code>true</code>, then the isometries in <span>$G$</span> are considered as matrix representation of their action on the standard basis of the ambient space of <span>$L$</span>. Otherwise, they are considered as matrix representation of their action on the basis matrix of <span>$L$</span>.</p></div></section></article><p>We will see later in the section about enumeration of lattices with isometry that one can compute <span>$G_{L,f}$</span> in some particular cases arising from equivariant primitive embeddings of lattices with isometries.</p><h2 id="Kernel-sublattices"><a class="docs-heading-anchor" href="#Kernel-sublattices">Kernel sublattices</a><a id="Kernel-sublattices-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel-sublattices" title="Permalink"></a></h2><p>As for single integer lattices, it is possible to compute kernel sublattices of some <span>$\mathbb{Z}$</span>-module homomorphisms. We provide here the possibility to compute <span>$\ker(p(f))$</span> as a sublattice of <span>$L$</span> equipped with the induced action of <span>$f$</span>, where <span>$p$</span> is a polynomial with rational coefficients.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="kernel_lattice-Tuple{ZZLatWithIsom, Union{QQPolyRingElem, ZZPolyRingElem}}" href="#kernel_lattice-Tuple{ZZLatWithIsom, Union{QQPolyRingElem, ZZPolyRingElem}}"><code>kernel_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kernel_lattice(Lf::ZZLatWithIsom, p::Union{ZZPolyRingElem, QQPolyRingElem})
                                                     -&gt; ZZLatWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> and a polynomial <span>$p$</span> with rational coefficients, return the sublattice <span>$M := \ker(p(f))$</span> of the underlying lattice <span>$L$</span> with isometry <span>$f$</span>, together with the restriction <span>$f_{\mid M}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; Zx,x = ZZ[&quot;x&quot;]
(Univariate polynomial ring in x over ZZ, x)

julia&gt; mf = minimal_polynomial(Lf)
x^5 - 1

julia&gt; factor(mf)
1 * (x - 1) * (x^4 + x^3 + x^2 + x + 1)

julia&gt; kernel_lattice(Lf, x-1)
Integer lattice of rank 1 and degree 5
  with isometry of finite order 1
  given by
  [1]

julia&gt; kernel_lattice(Lf, cyclotomic_polynomial(5))
Integer lattice of rank 4 and degree 5
  with isometry of finite order 5
  given by
  [-1   -1   -1   -1]
  [ 1    0    0    0]
  [ 0    1    0    0]
  [ 0    0    1    0]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="kernel_lattice-Tuple{ZZLatWithIsom, Integer}" href="#kernel_lattice-Tuple{ZZLatWithIsom, Integer}"><code>kernel_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kernel_lattice(Lf::ZZLatWithIsom, l::Integer) -&gt; ZZLatWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> and an integer <span>$l$</span>, return the kernel lattice of <span>$(L, f)$</span> associated to the <span>$l-$</span>th cyclotomic polynomial.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; kernel_lattice(Lf, 5)
Integer lattice of rank 4 and degree 5
  with isometry of finite order 5
  given by
  [-1   -1   -1   -1]
  [ 1    0    0    0]
  [ 0    1    0    0]
  [ 0    0    1    0]

julia&gt; kernel_lattice(Lf, 1)
Integer lattice of rank 1 and degree 5
  with isometry of finite order 1
  given by
  [1]</code></pre></div></section></article><p>Note that such sublattices are by definition primitive in <span>$L$</span> since <span>$L$</span> is non-degenerate. As particular kernel sublattices of <span>$L$</span>, one can also compute the so-called <em>invariant</em> and <em>coinvariant</em> lattices of <span>$(L, f)$</span>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="coinvariant_lattice-Tuple{ZZLatWithIsom}" href="#coinvariant_lattice-Tuple{ZZLatWithIsom}"><code>coinvariant_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coinvariant_lattice(Lf::ZZLatWithIsom) -&gt; ZZLatWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the coinvariant lattice <span>$L_f$</span> of <span>$(L, f)$</span> together with the restriction of <span>$f$</span> to <span>$L_f$</span>.</p><p>The coinvariant lattice <span>$L_f$</span> of <span>$(L, f)$</span> is the orthogonal complement in <span>$L$</span> of the invariant lattice <span>$L_f$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; coinvariant_lattice(Lf)
Integer lattice of rank 4 and degree 5
  with isometry of finite order 5
  given by
  [-1   -1   -1   -1]
  [ 1    0    0    0]
  [ 0    1    0    0]
  [ 0    0    1    0]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="invariant_lattice-Tuple{ZZLatWithIsom}" href="#invariant_lattice-Tuple{ZZLatWithIsom}"><code>invariant_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invariant_lattice(Lf::ZZLatWithIsom) -&gt; ZZLatWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the invariant lattice <span>$L^f$</span> of <span>$(L, f)$</span> together with the restriction of <span>$f$</span> to <span>$L^f$</span> (which is the identity in this case).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; invariant_lattice(Lf)
Integer lattice of rank 1 and degree 5
  with isometry of finite order 1
  given by
  [1]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="invariant_coinvariant_pair-Tuple{ZZLatWithIsom}" href="#invariant_coinvariant_pair-Tuple{ZZLatWithIsom}"><code>invariant_coinvariant_pair</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invariant_coinvariant_pair(Lf::ZZLatWithIsom) -&gt; ZZLatWithIsom, ZZLatWithIsom</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span>, return the pair of lattices with isometries consisting of <span>$(L^f, f_{\mid L^f})$</span> and <span>$(L_f, f_{\mid L_f})$</span>, the invariant and coinvariant sublattices with isometry of <span>$(L, f)$</span>.</p></div></section></article><p>Similarly, we provide the possibility to compute invariant and coinvariant sublattices given an orthogonal representation <code>G</code> in matrix form of a finite group on a given lattice <code>L</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="coinvariant_lattice-Tuple{ZZLat, MatrixGroup}" href="#coinvariant_lattice-Tuple{ZZLat, MatrixGroup}"><code>coinvariant_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coinvariant_lattice(L::ZZLat, G::MatrixGroup;
                              ambient_representation::Bool = true)
                                                    -&gt; ZZLat, MatrixGroup</code></pre><p>Given an integer lattice <span>$L$</span> and a group <span>$G$</span> of isometries of <span>$L$</span>, return the coinvariant sublattice <span>$L_G$</span> of <span>$L$</span>, together with the subgroup <span>$H$</span> of isometries of <span>$L_G$</span> induced by the action of <span>$G$</span>.</p><p>If <code>ambient_representation</code> is set to <code>true</code>, the isometries in <span>$G$</span> and <span>$H$</span> are considered as matrix representation of their action on the standard basis of the ambient space of <span>$L$</span>. Otherwise, they are considered as matrix representation of their action on the basis matrices of <span>$L$</span> and <span>$L_G$</span> respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,2);

julia&gt; G = isometry_group(L);

julia&gt; L2, G2 = coinvariant_lattice(L, G)
(Integer lattice of rank 2 and degree 2, Matrix group of degree 2 over QQ)

julia&gt; L == L2
true

julia&gt; G == G2
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="invariant_lattice-Tuple{ZZLat, MatrixGroup}" href="#invariant_lattice-Tuple{ZZLat, MatrixGroup}"><code>invariant_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invariant_lattice(L::ZZLat, G::MatrixGroup;
                            ambient_representation::Bool = true) -&gt; ZZLat</code></pre><p>Given an integer lattice <span>$L$</span> and a group <span>$G$</span> of isometries of <span>$L$</span> in matrix, return the invariant sublattice <span>$L^G$</span> of <span>$L$</span>.</p><p>If <code>ambient_representation</code> is set to <code>true</code>, the isometries in <span>$G$</span> are considered as matrix representation of their action on the standard basis of the ambient space of <span>$L$</span>. Otherwise, they are considered as matrix representation of their action on the basis matrix of <span>$L$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,2);

julia&gt; G = isometry_group(L);

julia&gt; invariant_lattice(L, G)
Integer lattice of rank 0 and degree 2
with gram matrix
0 by 0 empty matrix</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="invariant_coinvariant_pair-Tuple{ZZLat, MatrixGroup}" href="#invariant_coinvariant_pair-Tuple{ZZLat, MatrixGroup}"><code>invariant_coinvariant_pair</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invariant_coinvariant_pair(L::ZZLat, G::MatrixGroup;
                                     ambient_representation::Bool = true)
                                               -&gt; ZZLat, ZZLat, MatrixGroup</code></pre><p>Given an integer lattice <span>$L$</span> and a group <span>$G$</span> of isometries of <span>$L$</span>, return the invariant sublattice <span>$L^G$</span> of <span>$L$</span> and its coinvariant sublattice <span>$L_G$</span> together with the subgroup <span>$H$</span> of isometries of <span>$L_G$</span> induced by the action of <span>$G$</span> on <span>$L$</span>.</p><p>If <code>ambient_representation</code> is set to <code>true</code>, the isometries in <span>$G$</span> and <span>$H$</span> are considered as matrix representation of their action on the standard basis of the ambient space of <span>$L$</span>. Otherwise, they are considered as matrix representation of their action on the basis matrices of <span>$L$</span> and <span>$L_G$</span> respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,2);

julia&gt; G = isometry_group(L);

julia&gt; Gsub, _ = sub(G, [gens(G)[end]]);

julia&gt; F, C, G2 = invariant_coinvariant_pair(L, Gsub)
(Integer lattice of rank 1 and degree 2, Integer lattice of rank 1 and degree 2, Matrix group of degree 2 over QQ)

julia&gt; F
Integer lattice of rank 1 and degree 2
with gram matrix
[2]

julia&gt; C
Integer lattice of rank 1 and degree 2
with gram matrix
[6]</code></pre></div></section></article><h2 id="Signatures"><a class="docs-heading-anchor" href="#Signatures">Signatures</a><a id="Signatures-1"></a><a class="docs-heading-anchor-permalink" href="#Signatures" title="Permalink"></a></h2><p>We conclude this introduction about standard functionalities for lattices with isometry by introducing a last invariant for lattices with finite isometry of hermitian type <span>$(L, f)$</span>, called the <em>signatures</em>. These signatures are intrinsically connected to the local archimedean invariants of the hermitian structure associated to <span>$(L, f)$</span> via the trace equivalence.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="signatures-Tuple{ZZLatWithIsom}" href="#signatures-Tuple{ZZLatWithIsom}"><code>signatures</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signatures(Lf::ZZLatWithIsom) -&gt; Dict{Int, Tuple{Int, Int}}</code></pre><p>Given a lattice with isometry <span>$(L, f)$</span> where the minimal polynomial of <span>$f$</span> is irreducible cyclotomic, return the signatures of the pair <span>$(L, f)$</span>.</p><p>In this context, if we denote <span>$z$</span> a primitive <span>$n$</span>-th root of unity, where <span>$n$</span> is the order of <span>$f$</span>, then for each <span>$1 \leq i \leq n/2$</span> such that <span>$(i, n) = 1$</span>, the <span>$i$</span>-th signature of <span>$(L, f)$</span> is given by the signatures of the real quadratic form <span>$\ker(f + f^{-1} - z^i - z^{-i})$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = root_lattice(:A,5);

julia&gt; f = matrix(QQ, 5, 5, [1  1  1  1  1;
                             0 -1 -1 -1 -1;
                             0  1  0  0  0;
                             0  0  1  0  0;
                             0  0  0  1  0]);

julia&gt; Lf = integer_lattice_with_isometry(L, f);

julia&gt; M = coinvariant_lattice(Lf);

julia&gt; signatures(M)
Dict{Integer, Tuple{Int64, Int64}} with 2 entries:
  2 =&gt; (2, 0)
  1 =&gt; (2, 0)</code></pre></div></section></article><h2 id="Equality"><a class="docs-heading-anchor" href="#Equality">Equality</a><a id="Equality-1"></a><a class="docs-heading-anchor-permalink" href="#Equality" title="Permalink"></a></h2><p>We choose as a convention that two pairs <span>$(L, f)$</span> and <span>$(L&#39;, f&#39;)$</span> of integer lattices with isometries are <em>equal</em> if their ambient quadratic space with isometry of type <a href="../spacewithisom/#QuadSpaceWithIsom"><code>QuadSpaceWithIsom</code></a> are equal, and if the underlying lattices <span>$L$</span> and <span>$L&#39;$</span> are equal as <span>$\mathbb Z$</span>-modules in the common ambient quadratic space.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../spacewithisom/">« Quadratic spaces with isometry</a><a class="docs-footer-nextpage" href="../enumeration/">Enumeration of isometries »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.0 on <span class="colophon-date" title="Friday 1 December 2023 15:48">Friday 1 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
